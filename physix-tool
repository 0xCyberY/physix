#!/usr/bin/python3
import os
import sys
import json
import sqlite3
import tarfile
import logging
import datetime
import subprocess
from optparse import OptionParser

BUILDROOT = "/mnt/physix"
FAILURE = 1
SUCCESS = 0

#---------------------------------------------
# DB Functions
#---------------------------------------------
def get_db_connection():
    ''' Return db connection object 
        Return None on error '''
    conn = None
    try:
        conn = sqlite3.connect('/opt/DB.physix')
        if setup_table(conn):
            '''error()'''
            error("Failed: Set Table")
            return None
    except Exception as e:
        error(str(e))
        return None
    return conn


def get_stack_table_size(conn):
    ''' Return Integer: Number of rows of STACK Table 
        return None on error '''
    try:
        sql_count = "SELECT COUNT(*) FROM STACK;"
        c = conn.cursor()
        c.execute(sql_count)
        ret = c.fetchall()
        if len(ret) != 0:
            if len(ret[0]) != 0:
                return int(ret[0][0])
        return None
    except Exception as e:
        error(e)
        return None


def setup_table(conn):
    """ If table doese not exist, create it
        If table does not have init row, create it 
        return SUCCESS/FAILURE """

    sql_create_stack_table = """ CREATE TABLE IF NOT EXISTS STACK (
                                        ID integer PRIMARY KEY AUTOINCREMENT,
                                        SP text,
                                        TIME text NOT NULL,
                                        OP text NOT NULL,
                                        COMMITID text,
                                        SNAPID text,
                                        PKG text,
                                        SCRIPT text
                                    ); """

    try:
        c = conn.cursor()
        c.execute(sql_create_stack_table)
        conn.commit()
    except Exception as e:
        error(e)
        return FAILURE

    tsize = get_stack_table_size(conn)
    if tsize != None and tsize == 0:
        init_row = row_factory('*', "INIT", 'INIT', 'INIT', 'INIT', 'INIT')
        insert_row(conn, init_row)
    return SUCCESS


def row_factory(sp, op, commit, snapid, pkg, script):
    ''' Return String: a new entry for insertion  '''
    date = format(datetime.datetime.now())

    #ret_tpl = run_cmd(['git', 'log', '--oneline', '-n', '1'])
    #cid = ''
    #if validate(ret_tpl,'git commit ID'):
    #    commit = str(ret_tpl[1])
        
    return (sp, date, op, commit, snapid, pkg, script)

def insert_row(conn, data):
    sql = ''' INSERT INTO STACK (SP,TIME,OP,COMMITID,SNAPID,PKG,SCRIPT) VALUES(?,?,?,?,?,?,?) '''
    try:
        cur = conn.cursor()
        cur.execute(sql, data)
        conn.commit()
    except Exception as e:
        error(str(e))
        return FAILURE
    return SUCCESS


def get_sp_key(conn):
    ''' Return initeger: row key of stack pointer 
        Return None on error'''
    row = ''

    try:
        cur = conn.cursor()
        cur.execute("SELECT * FROM STACK WHERE SP='*'")
        row = cur.fetchall()

        if type(row) == list and len(row) == 1:
            tpl = row[0]
            if type(tpl) == tuple and len(tpl) == 7:
                return int(tpl[0])
            else:
                error("Unexpected tuple size")
                return None
    except Exception as e:
        errpr(e)
        return None


def list_stack(conn):
    stack_lst = []
    try:
        cur = conn.cursor()
        cur.execute("SELECT * FROM STACK")
        stack_lst = cur.fetchall()
    except Exception as e:
        error(e)
        return FAILURE

    info("Stack Size: "+str(len(stack_lst)))
    for i in range(len(stack_lst)-1, -1, -1):
        print(str(stack_lst[i]))
    return SUCCESS


#---------------------------------------------
# INIT FUNCTIONS
#---------------------------------------------
def validate(rtn_tpl, msg, report=True):
    """ Log appropriate message based on return code"""
    rcode = int(rtn_tpl[0])
    if rcode == SUCCESS:
        if report == True:
            ok(msg)
        return SUCCESS
 
    error(msg)
    error("RTN:"+str(rtn_tpl[0]))
    error("stdout:"+str(rtn_tpl[1]))
    error("stderr:"+str(rtn_tpl[2]))
    return FAILURE


def info(msg):
    """ write info message to log """
    print("\033[0;33;48m [INFO] \033[0m " + msg)
    logging.info(msg)


def error(msg):
    """ write error message to log """
    msg = "\033[0;31;48m [ERROR] \033[0m " + msg
    print(msg)
    logging.error(msg)


# \e[92m[OK]\e[0m
def ok(msg):
    """ write success message to log """
    msg = "\033[0;32;48m [OK] \033[0m   " + msg
    print(msg)
    logging.info(msg)


def set_build_lock():
    if not os.path.exists('/run/lock/buildbox.lock'):
        rtn_tpl = run_cmd(['touch', '/run/lock/buildbox.lock'])
        return validate(rtn_tpl,"Set /run/lock/buildbox.lock")
    else:
        error("buildbox.lock Already set.")
        return FAILURE


def unset_build_lock():
    if os.path.exists('/run/lock/buildbox.lock'):
        rtn_tpl = run_cmd(['rm', '/run/lock/buildbox.lock'])
        return validate(rtn_tpl,"buildbox.lock removed")
    else:
        error("buildbox.lock not Set.")
        return FAILURE


def load_recipe(cfg):
    """ Read in recipe as dict """
    with open(cfg) as file_desc:
        return json.load(file_desc)


def load_build_config(cfg):
    """ cfg : string """
    config = {}
    with open(cfg, "r") as file_desc:
        lines = file_desc.readlines()
        for line in lines:
            line = line.strip().strip().strip("\n")

            if line.startswith('#') or len(line) == 0:
                continue

            lst = line.split("=")
            if len(lst) != 2:
                error("Unexpected Format")

            cfg = str(lst[0])
            val = str(lst[1])
            config[cfg] = val
    return config


#---------------------------------------------
#---------------------------------------------
def verify_checker(config):
    """ config : {} """

    filesystem = config['CONF_ROOTPART_FS']
    mkfs  = "mkfs." + filesystem
    for tool in ['mkfs.fat', 'mkfs.ext2', mkfs, 'gcc', 'g++', 'make', 'gawk', 'bison']:
        ret_tpl = run_cmd(['which', tool])
        if validate(ret_tpl, "Check: "+ tool):
            return FAILURE

    root_dev = config["CONF_ROOT_DEVICE"]
    devlst = os.listdir("/dev")
    dev_count = sum(1 for ln in devlst if root_dev in ln)
    if dev_count > 1:
        msg = "".join(["Found Existing partition(s) on: /dev/", root_dev,
                       "Please remove them and restart this opperation"])
        error(msg)
        return FAILURE

    return SUCCESS


#---------------------------------------------
#---------------------------------------------
def create_partitions(config):
    """ config : {} """
    root_device = "/dev/" + config["CONF_ROOT_DEVICE"]
    rtn = root_device = root_device.strip("\n")

    # UEFI 1
    uefi_size = config["CONF_UEFI_PART_SIZE"].strip("\n")
    ret_tpl = run_cmd(["parted", root_device, "mkpart", "primary", "1", uefi_size])
    if validate(ret_tpl, "Create UEFI Partition"):
        return FAILURE

    # BOOT PART
    boot_size = config["CONF_BOOT_PART_SIZE"].strip("\n")
    boot_boundery = str(int(uefi_size) + int(boot_size))
    ret_tpl = run_cmd(['parted', root_device, "mkpart", "primary", uefi_size, boot_boundery])
    if validate(ret_tpl, "Create /boot Partition"):
        return FAILURE

    psize = config['CONF_PHYS_ROOT_PART_SIZE'].strip("\n")
    phys_boundery = str(int(boot_boundery) + int(psize))
    ret_tpl = run_cmd(['parted', root_device, "mkpart", "primary", boot_boundery, phys_boundery])
    if validate(ret_tpl, "Create ROOT Partition"):
        return FAILURE

    ret_tpl = run_cmd(['parted', root_device, 'set', '1', 'boot', 'on'])
    if validate(ret_tpl, "Boot Flag Set to "+root_device):
        return FAILURE

    return SUCCESS


#---------------------------------------------
#---------------------------------------------
def create_volumes(config):
    """ Create lvm volumes """

    system_root = "/dev/" + config["CONF_ROOT_DEVICE"].strip('\n')
    system_root = system_root + "3"
    ret_tpl = run_cmd(['pvcreate', '-ff', '-y', system_root])
    if validate(ret_tpl, "Physical Volume Create: "+system_root):
        return FAILURE

    vol_group_name = config["CONF_VOL_GROUP_NAME"].strip("\n")
    ret_tpl = run_cmd(['vgcreate', '-ff', vol_group_name, system_root])
    if validate(ret_tpl, ""):
        return FAILURE

    root_vol_size = str(config["CONF_LOGICAL_ROOT_SIZE"].strip('\n'))+"G"
    ret_tpl = run_cmd(['lvcreate', '--yes', '-L', root_vol_size, '-n', 'root', vol_group_name])
    if validate(ret_tpl, "Volume Create: root"):
        return FAILURE

    home_vol_size = str(config["CONF_LOGICAL_HOME_SIZE"].strip('\n')) + "G"
    ret_tpl = run_cmd(["lvcreate", '--yes', "-L", home_vol_size, '-n', 'home', vol_group_name])
    if validate(ret_tpl, "Volume Create: home"):
        return FAILURE

    var_vol_size = str(config["CONF_LOGICAL_VAR_SIZE"].strip('\n')) + "G"
    ret_tpl = run_cmd(["lvcreate", '--yes', "-L", var_vol_size, '-n', 'var', vol_group_name])
    if validate(ret_tpl, "Volume Create: var"):
        return FAILURE

    #usr_vol_size = str(config["CONF_LOGICAL_USR_SIZE"].strip('\n')) + "G"
    #ret_tpl = run_cmd(["lvcreate", '--yes', "-L", usr_vol_size, '-n', 'usr', vol_group_name])
    #if validate(ret_tpl, "Volume Create: usr"):
    #    return FAILURE

    opt_vol_size = str(config["CONF_LOGICAL_OPT_SIZE"].strip('\n')) + "G"
    ret_tpl = run_cmd(["lvcreate", '--yes', "-L", opt_vol_size, '-n', 'opt', vol_group_name])
    if validate(ret_tpl, "Volume Create: opt"):
        return FAILURE

    tmp_vol_size = str(config["CONF_LOGICAL_TMP_SIZE"].strip('\n')) + "G"
    ret_tpl = run_cmd(["lvcreate", '--yes', "-L", tmp_vol_size, '-n', 'tmp', vol_group_name])
    if validate(ret_tpl, "Volume Create: opt"):
        return FAILURE

    return SUCCESS


#---------------------------------------------
#---------------------------------------------
def format_volumes(config):
    """ Format lvm volumes and partitions """

    filesystem = config['CONF_ROOTPART_FS']
    mkfs_cmd  = "mkfs." + filesystem

    system_root = "/dev/" + config["CONF_ROOT_DEVICE"]
    vol_group_name = config["CONF_VOL_GROUP_NAME"]

    part1 = system_root + "1"
    ret_tpl = run_cmd(['mkfs.fat', part1])
    if validate(ret_tpl, "mkfs.fat: " + part1):
        return FAILURE

    part2 = system_root + "2"
    ret_tpl = run_cmd(['mkfs.ext2', part2])
    if validate(ret_tpl, "mkfs.ext2: " + part2):
        return FAILURE

    physix_root = "/dev/mapper/" + vol_group_name + "-root"
    ret_tpl = run_cmd([mkfs_cmd, physix_root])
    if validate(ret_tpl, mkfs_cmd+":"+physix_root):
        return FAILURE

    physix_home = "/dev/mapper/" + vol_group_name + "-home"
    ret_tpl = run_cmd([mkfs_cmd, physix_home])
    if validate(ret_tpl, mkfs_cmd+":"+physix_home):
        return FAILURE

    physix_var = "/dev/mapper/" + vol_group_name + "-var"
    ret_tpl = run_cmd([mkfs_cmd, physix_var])
    if validate(ret_tpl, mkfs_cmd+""+physix_var):
        return FAILURE

    #physix_usr = "/dev/mapper/" + vol_group_name + "-usr"
    #ret_tpl = run_cmd([mkfs_cmd, physix_usr])
    #if validate(ret_tpl, mkfs_cmd+":"+physix_usr):
    #    return FAILURE

    physix_opt = "/dev/mapper/" + vol_group_name + "-opt"
    ret_tpl = run_cmd([mkfs_cmd, physix_opt])
    if validate(ret_tpl, mkfs_cmd+":"+ physix_opt):
        return FAILURE

    physix_tmp = "/dev/mapper/" + vol_group_name + "-tmp"
    ret_tpl = run_cmd([mkfs_cmd, physix_tmp])
    if validate(ret_tpl, mkfs_cmd+":"+physix_tmp):
        return FAILURE

    return SUCCESS


#---------------------------------------------
#--------------------------------------------
def mount_volumes(config):
    """ Mount volumes and partitions """

    vol_group_name = config["CONF_VOL_GROUP_NAME"]

    if not os.path.exists(BUILDROOT):
        os.mkdir(BUILDROOT, 755)

    volume_root = "/dev/mapper/" + vol_group_name + "-root"
    ret_tpl = run_cmd(['mount', volume_root, BUILDROOT])
    if validate(ret_tpl, "Mount: "+volume_root):
        return FAILURE

    mnt_point = BUILDROOT + "/home"
    os.mkdir(mnt_point, 0o755)
    volume_home = "/dev/mapper/" + vol_group_name + "-home"
    ret_tpl = run_cmd(['mount', volume_home, mnt_point])
    if validate(ret_tpl, "Mount: " + volume_home):
        return FAILURE

    var = BUILDROOT + "/var"
    os.mkdir(var, 0o755)
    volume_var = "/dev/mapper/" + vol_group_name + "-var"
    mnt_point = BUILDROOT + "/var"
    ret_tpl = run_cmd(['mount', volume_var, mnt_point])
    if validate(ret_tpl, "Mount: " + volume_var):
        return FAILURE

    #usr = BUILDROOT + "/usr"
    #os.mkdir(usr, 0o755)
    #volume_usr = "/dev/mapper/" + vol_group_name + "-usr"
    #mnt_point = BUILDROOT + "/usr"
    #ret_tpl = run_cmd(['mount', volume_usr, mnt_point])
    #if validate(ret_tpl, "Mount: " + volume_usr):
    #    return FAILURE

    opt = BUILDROOT + "/opt"
    os.mkdir(opt, 0o755)
    volume_opt = "/dev/mapper/" + vol_group_name + "-opt"
    mnt_point = BUILDROOT + "/opt"
    ret_tpl = run_cmd(['mount', volume_opt, mnt_point])
    if validate(ret_tpl, "Mount: " + volume_opt):
        return FAILURE

    boot = BUILDROOT + "/boot"
    os.mkdir(boot, 0o755)
    boot_part = "/dev/" + config["CONF_ROOT_DEVICE"].strip('\n') + "2"
    ret_tpl = run_cmd(['mount', boot_part, boot])
    if validate(ret_tpl, "Mount: " + boot_part):
        return FAILURE

    return SUCCESS


def get_sources_prefix(context):
    if context == "CHRT":
        return '/opt/sources.physix/'
    elif context == "NON-CHRT":
        return '/mnt/physix/opt/sources.physix/'
    else:
        error("get_sources_prefix: Unknown context")
        return False


def get_physix_prefix(context):
    if context == "CHRT":
        return '/opt/physix/'
    elif context == "NON-CHRT":
        return '/mnt/physix/opt/physix/'
    else:
        error("get_physix_prefix: Unknown context")
        return False


def verify_file_md5(fname, rmd5, context):
    prefix = get_sources_prefix(context)
    fname = prefix + fname

    ret_tpl = run_cmd(['md5sum', fname])
    if ret_tpl[0] == 0:
        cmpr_md5 = ret_tpl[1].split(' ')[0]
        cmpr_md5 = cmpr_md5.replace("b'", "")
        if cmpr_md5 == rmd5:
            ok("MD5 Verified: "+fname+" : "+cmpr_md5)
            return True
        else:
            error("MD5 Verified: "+fname+" : "+cmpr_md5 +":"+rmd5)
    return False


#----------------------------------------------------
#----------------------------------------------------
def verify_recipe_md5(recipe, context):
    for i in range(len(recipe['build_queue'])):
        element = recipe[str(i)]
        sources = element['sources']

        for url in sources.keys():
            rmd5 = sources[url]
            archv_name = url.split("/")[-1]

            if not verify_file_md5(archv_name, rmd5, context):
                return FAILURE

    return SUCCESS


#----------------------------------------------------
#---------------------------------------------------
def pull_sources(recipe, dest):
    """ Download sources """
    dir_prefix = '--directory-prefix=' + dest
    rsize = len(recipe['build_queue'])

    if not os.path.exists(dest):
        os.mkdir(dest, 0o755)
        if not os.path.exists(dest):
            error("Destination Path Creation Failed:" + dest)

    pull_lst = []
    for i in range(rsize):
        sources = recipe[str(i)]["sources"]
        for key in sources.keys():
            pull_lst.append(key)

    for url in pull_lst:
        if url:
            ret_tpl = run_cmd(['wget', '-q', '--continue', dir_prefix, url])
            if validate(ret_tpl, "Download: "+url, True):
                return FAILURE

    return SUCCESS


def setup_build_env(element, context):
    """ Setup build directory. Returns boolean on success/failure """
    src_prefix = get_sources_prefix(context)
    if src_prefix == False:
        return FAILURE
    bb_path = os.path.join(src_prefix, "BUILDBOX")

    if not refresh_build_box(context):
        error("refresh_build_box")
        return FAILURE

    physix_prefix = get_physix_prefix(context)
    if physix_prefix == False:
        return FAILURE

    include = os.path.join(physix_prefix, "include.sh")
    ret_tpl = run_cmd(['cp', include, bb_path])
    if validate(ret_tpl, 'Copy include.sh to BUILDBOX'):
        return FAILURE

    buildconf =  os.path.join(physix_prefix, "build.conf")
    ret_tpl = run_cmd(['cp', buildconf, bb_path])
    if validate(ret_tpl, 'Copy build.conf to BUILDBOX'):
        return FAILURE

    for patch in element["patches"]:
        patch_path = os.path.join(src_prefix, patch)
        ret_tpl = run_cmd(['cp', patch_path, bb_path])
        if validate(ret_tpl, 'Copy patch to BUILDBOX'):
            return FAILURE

    for archive in element["archives"]:
        #archive_path = src_path + archive
        archive_path = os.path.join(src_prefix, archive)
        ret_tpl = run_cmd(['cp', archive_path, bb_path])
        if validate(ret_tpl, 'Copy archive to BUILDBOX'):
            return FAILURE
    return SUCCESS

#---------------------------------------------
#--------------------------------------------
def setup(config):
    """ Setup environment for system build """
    if not os.path.exists(BUILDROOT+"/opt"):
        os.mkdir(BUILDROOT+"/opt", 755)
    if not os.path.exists(BUILDROOT+"/opt/logs.physix"):
        os.mkdir(BUILDROOT+"/opt/logs.physix", 777)
    if not os.path.exists(BUILDROOT+"/opt/sources.physix"):
        os.mkdir(BUILDROOT+"/opt/sources.physix", 770)

    # First find bash
    ret_tpl = run_cmd(['ln', '-sfv', '/usr/bin/bash', '/usr/bin/sh'])
    if validate(ret_tpl, "link bash to 'sh/bash'"):
        return FAILURE

    # First find gawk
    ret_tpl = run_cmd(['ln', '-sfv', '/usr/bin/gawk', '/usr/bin/awk'])
    if validate(ret_tpl, "link gawk to 'awk/gawk'"):
        return FAILURE

    # First find bison
    ret_tpl = run_cmd(['ln', '-sfv', '/usr/bin/bison', '/usr/bin/yacc'])
    if validate(ret_tpl, "link gawk to 'yacc/bison'"):
        return FAILURE

    tools = BUILDROOT+"/tools"
    ret_tpl = run_cmd(['ln', '-sfv', tools, '/'])
    if validate(ret_tpl, "link tools dir"):
        return FAILURE

    (rtn, out, err) = run_cmd(['grep', 'physix', '/etc/passwd'])
    if int(rtn) != 0:
        ret_tpl = run_cmd(['useradd', '-s', '/bin/bash', '-m', 'physix'])
        if validate(ret_tpl, "useradd physix"):
            return FAILURE

    src = str(os.getcwd()) + "/build-scripts/03-base-config/configs/physix-bashrc"
    dest = "/home/physix/.bashrc"
    ret_tpl = run_cmd(['cp', src, dest])
    if validate(ret_tpl, "set physix user's .bashrc file"):
        return FAILURE

    tools_dir = BUILDROOT + "/tools"
    os.mkdir(tools_dir, 0o755)
    ret_tpl = run_cmd(['chown', '-v', 'physix', tools_dir])
    if validate(ret_tpl, "chown "+tools_dir):
        return FAILURE

    ret_tpl = run_cmd(['chmod', '750', tools_dir])
    if validate(ret_tpl, "chmod 770 "+tools_dir):
        return FAILURE

    sources_dir = BUILDROOT + "/opt/sources.physix"
    ret_tpl = run_cmd(['chown', '-v', 'physix', sources_dir])
    if validate(ret_tpl, "chown "+sources_dir):
        return FAILURE

    ret_tpl = run_cmd(['chmod', '750', sources_dir])
    if validate(ret_tpl, "chmod 750 "+sources_dir):
        return FAILURE

    ret_tpl = run_cmd(['mv', os.getcwd(), '/mnt/physix/opt/'])
    if validate(ret_tpl, "Move physix repo to /mnt/physix/opt/"):
        return FAILURE

    return SUCCESS 

#---------------------------------------------
#---------------------------------------------
def build_toolchain(recipe, context, build_num=0):
    """ Build the temorary toolchain from recipe """

    for i in range(build_num, len(recipe['build_queue'])):
        buildq = recipe['build_queue']
        build_id = str(buildq[i])
        element  = recipe[build_id]

        stat = " ".join(["Build [", str(i), "/", str(len(recipe)), "] Toolchain" ] )
        info(stat)

        if setup_build_env(element, context):
            return FAILURE

        ''' Fails on error '''
        if unpack(element, context):
            return FAILURE

        """ Dir name of First tarball in list is passed as arg to the 
            build script """
        build_src = ''
        if element["archives"] != []:
            bsp = os.path.join(get_sources_prefix(context), str(element["archives"][0]))
            build_src = top_most_dir(bsp)

        subcmd = os.path.join('/mnt/physix/opt/physix/build-scripts/',
                              str(element["group"]),
                              str(element["build_script"]))
        subcmd = " ".join([subcmd, build_src])
        cmd = ['su', 'physix', '-c', subcmd]

        info("Building " + str(cmd))
        ret_tpl = run_cmd_log(cmd, str(element["build_script"]), "")
        if validate(ret_tpl, "Build: " + str(cmd), True):
            return FAILURE

    return SUCCESS


#---------------------------------------------
#---------------------------------------------
def build_recipe(recipe, context, build_num):
    """ Build recipe """

    for i in range(build_num, len(recipe['build_queue'])):
        buildq = recipe['build_queue']
        build_id = str(buildq[i])
        element  = recipe[build_id]

        stat = " ".join(["Building [", str(i), "/", str(len(recipe['build_queue'])), "]" ] )
        info(stat)

        if set_build_lock():
            return FAILURE

        if setup_build_env(element, context):
            return FAILURE

        unpack(element, context)

        """ Dir name of First tarball in list, is passed as arg to the 
            build script """
        if element["archives"] != []:
            bsp = "/opt/sources.physix/"+ str(element["archives"][0])
            build_src = top_most_dir(bsp)
        else:
            build_src = ''

        subcmd = os.path.join('/opt/physix/build-scripts/',
                              str(element["group"]),
                              str(element["build_script"]))
        cmd = [subcmd, build_src]

        info("Executing Build: " + "[" + str(build_num) + "] " + str(cmd))
        #os.chdir('/opt/sources.physix/BUILDBOX')
        ret_tpl = run_cmd_log(cmd, str(element["build_script"]), context)
        #os.chdir('/opt/physix')
        if validate(ret_tpl, "Build: "+str(cmd), True):
            unset_build_lock()
            return FAILURE

        db = get_db_connection()
        if db:
            entry = row_factory('', 'BUILD', '123456', '', build_src, str(element["build_script"]))
            if insert_row(db, entry):
                error("DB: Failed to insert entry")
                return FAILURE
            db.close()

        if unset_build_lock():
            return FAILURE



#---------------------------------------------
# Input: string - recipe : Recipe file path
# Input: string - chroot or non chroot context
# Input: int - Start building from recipe at line number
#---------------------------------------------
def build_base(recipe, context, build_num):
    """ Build base system from recipe """

    if build_num == 0:
        cmd = ['/mnt/physix/opt/physix/build-scripts/02-base/2.000-base-build-prep.sh']
        ret_tpl = run_cmd_log(cmd, "2.000-base-build-prep.sh", "")
        if validate(ret_tpl, "Build: " + str(cmd)):
            return FAILURE

    for i in range(build_num, len(recipe['build_queue'])):
        buildq = recipe['build_queue']
        build_id = str(buildq[i])
        element  = recipe[build_id]

        stat = " ".join(["Building [", str(i), "/", str(len(recipe['build_queue'])), "] Base System" ] )
        info(stat)

        if setup_build_env(element, context):
            error("Failed to stup build_env")
            return FAILURE

        if unpack(element, context):
            error("Failed to unpack")
            return FAILURE

        """ Dir name of First tarball in list, is passed as arg to the 
            build script """
        if element["archives"] != []:
            bsp = "/mnt/physix/opt/sources.physix/"+ str(element["archives"][0])
            build_src = top_most_dir(bsp)
        else:
            build_src = ''

        cmd = ['/mnt/physix/opt/physix/build-scripts/02-base/000-chroot_stub.sh',
               str(element["build_script"]),
               build_src]
        info("Executing Build: " + "[" + str(build_num) + "] " + str(cmd))
        ret_tpl = run_cmd_log(cmd, str(element["build_script"]), "")
        if validate(ret_tpl, "Build: " + str(cmd), True):
            return FAILURE


#---------------------------------------------
# Sees system as /mnt/physix/opt/physix
#---------------------------------------------
def config_base_system(recipe, context, build_num):
    """ Configure the base system from recipe """

    for i in range(build_num, len(recipe['build_queue'])):
        element = recipe[str(i)]

        stat = " ".join(["Building [", str(i), "/", str(len(recipe['build_queue'])), "] Config Base System" ])
        info(stat)

        if setup_build_env(element, context):
            error("Failed to stup build_env")
            return False

        """ Fails on error """
        if unpack(element, context):
            return FAILURE

        """ Dir name of First tarball in list, is passed as arg to the 
            build script """
        if element["archives"] != []:
            bsp = "/mnt/physix/opt/sources.physix/"+ str(element["archives"][0])
            build_src = top_most_dir(bsp)
        else:
            build_src = ''

        cmd = ['/mnt/physix/opt/physix/build-scripts/03-base-config/000-conf_chrrot_stub.sh',
               str(element["build_script"]),
               build_src]
        info("Executing Build: " + "[" + str(build_num) + "] " + str(cmd))
        ret_tpl = run_cmd_log(cmd, str(element["build_script"]), "")
        if validate(ret_tpl, "Build: "+str(cmd), True):
            return FAILURE

    """ Special case for user to set password without logging"""
    cmd = ['/mnt/physix/opt/physix/build-scripts/03-base-config/000-conf_chrrot_stub.sh',
           '3.111-set-passwd.sh']
    run_cmd_live(cmd)


#---------------------------------------------
#---------------------------------------------
def run_cmd_log(cmd, name, context):
    """ run command and log I/O to log file  """
    date = format(datetime.datetime.now())
    date = date.replace(":", "-").replace(" ", "-")
    log_name = date + "-" + name

    if context == "CHRT":
        log_path = "/opt/logs.physix/" + log_name
    else:
        log_path = "/mnt/physix/opt/logs.physix/" + log_name

    with open(log_path, "w") as file_desc:
        try:
            p = subprocess.run(cmd, stdout=file_desc, stderr=file_desc)
            rtn = int(p.returncode)
        except Exception as exc:
            error("[ERROR] Opperation Failed:"+str(exc)),

    return (rtn, "", "")


#---------------------------------------------
#---------------------------------------------
def run_cmd(cmd):
    """ Run command, return caputured I/O Streams """
    out = ''
    err = ''
    try:
        p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        rtn = int(p.returncode)
        out = str(p.stdout)
        err = str(p.stderr)
    except Exception as exc:
        error("[Exceotion] Opperation Failed:\n "+str(exc))

    rtn = (int(rtn), str(out), str(err))
    #info("Returning:" + str(rtn))
    return rtn

#-----------------------------------------------------
#-----------------------------------------------------
def run_cmd_live(cmd):
    """ run commmand, don't capture output  """
    try:
        proc = subprocess.run(cmd)
        rtn = int(proc.returncode)
    except Exception as exc:
        error("[ERROR] run_cmd Execption."+str(exc)),
    return (rtn, "", "")


#-----------------------------------------------------
# Input: string - path to archive
# Output: string -  top most directory from archive
#-----------------------------------------------------
def top_most_dir(archive_path):
    """ Return name of directory encapsolated in the tar archive """
    archive_path = archive_path.strip().strip("\n")
    if not os.path.exists(archive_path):
        error("Expected path does not exist: " + archive_path)
    with tarfile.open(archive_path, mode='r') as archive:
        tmd = str(os.path.commonprefix(archive.getnames()))
        ''' Sometimes a path is returned '''
        tmd_lst = tmd.split("/")
        name_lst = list(filter(len, tmd_lst))
        return str(name_lst[0])



def common_prefix(archive_name, context):
    src_prefix = get_sources_prefix(context)
    tmpdir = src_prefix + "BUILDBOX/tmp/"
    p = src_prefix + "BUILDBOX/" + archive_name
    q = tmpdir + archive_name

    if os.path.exists(tmpdir):
        run_cmd(['rm', 'r', tmpdir])
    run_cmd(['mkdir', tmpdir])

    if ('tar' in archive_name) or ('tgz' in archive_name):
        ret_tpl = run_cmd(['tar', 'xf', p, '-C', tmpdir])
        if not validate(ret_tpl, 'unpack to buildbox :' + archive_name):
            return False
    elif 'bz2' in archive:
        ''' Not a tar arvhive, but a straight bz2 compressed file '''
        ret_tpl = run_cmd(['cp', p, q])
        if not validate(ret_tpl, 'cp bz2 to tmp'):
            return False
        ret_tpl = run_cmd(['bunzip2', '-dk', q])
        if not validate(ret_tpl, 'bunzip2: ' + q):
            return False


    lst = os.listdir(tmpdir)
    return lst


#---------------------------------------------
#---------------------------------------------
def refresh_build_box(context):
    """ Remove and Re-create BUILDBOX """

    prefix = get_sources_prefix(context)
    bb_path = prefix + "BUILDBOX"

    if os.path.exists(bb_path):
        ret_tpl = run_cmd(['rm', '-r', bb_path])
        validate(ret_tpl, '')

        os.mkdir(bb_path, 0o700)
        ret_tpl = run_cmd(['mkdir', '-p', bb_path])
        validate(ret_tpl, "mkdir bb_path: " + bb_path)

        ret_tpl = run_cmd(['chown', 'physix:root', bb_path])
        validate(ret_tpl, "chown physix " + bb_path)
    else:
        os.mkdir(bb_path, 0o700)
        ret_tpl = run_cmd(['chown', 'physix:root', bb_path])
        validate(ret_tpl, "chown physix " + bb_path)

    return True


#---------------------------------------------
# This is hard to read. re-write better
# input: element:dict, context:string
# output: list of directory names from extracted tarbballs
#---------------------------------------------
def unpack(element, context):
    """ Move extract archives, and patches to BUILDBOX dir """
    dir_list = []
    archive_list = []

    if element['archives'] == []:
        return []

    # Archives are stored in 1 or 2 paths, depending on
    # whether executed in chrooted or non-chrooted context
    src_path = get_sources_prefix(context)
    bb_path = src_path + "BUILDBOX/"

    if not os.path.exists(bb_path):
        error("Build Env Nnt Found")
        return FAILURE

    for archive in element["archives"]: 
        info('Unpacking:'+archive)
        archive_path = bb_path + archive

        if not os.path.exists(archive_path):
            error("Archive not found in BUILDBOX: "+archive_path)
            return FAILURE

        if ('tar' in archive) or ('tgz' in archive):
            ret_tpl = run_cmd(['tar', 'xf', archive_path, '-C', bb_path])
            if validate(ret_tpl, 'unpack to buildbox :' + archive_path):
                error("Tar Failure")
                return FAILURE
        elif 'bz2' in archive:
            ''' Not a tar arvhive, but a straight bz2 compressed file '''
            ret_tpl = run_cmd(['bunzip2', '-dk', archive_path])
            if validate(ret_tpl, 'bunzip2: ' + archive_path):
                error("unzip failure")
                return FAILURE

    # ASSIGN OWNERSHIP TO 'physix'
    ret_tpl = run_cmd(['chown', '--recursive', 'physix:root', bb_path])
    if validate(ret_tpl, "chown bbox"):
        error("Failed to chown BUILDBOX")
        return FAILURE

    return SUCCESS


def do_partition_init(options):
    logging.basicConfig(filename='/tmp/physix-build.log', level=logging.DEBUG)
    
    BUILD_CONFIG = load_build_config(options.build_conf)

    # rename sysreq_check
    if verify_checker(BUILD_CONFIG):
        error("Systemd Requirement check")
        return FAILURE
    ok("Systemd Requirement check")

    info("Creating Partitions")
    if create_partitions(BUILD_CONFIG):
        error("Creating Partitions")
        return FAILURE
    ok("Creating Partitions")

    info("Creating Volumes")
    if create_volumes(BUILD_CONFIG):
        error("Creating Volumes")
        return FAILURE
    ok("Create Volumes")

    info("Formating Volumes")
    if format_volumes(BUILD_CONFIG):
        error("Formating Volumes")
        return FAILURE
    ok("Format Volumes")

    info("Mounting Volumes")
    if mount_volumes(BUILD_CONFIG):
        error("Mounting Volumes")
        return FAILURE
    ok("Mounting Volumes")

    if setup(BUILD_CONFIG):
        return FAILURE

    info("------------------------------------")
    info("- Build initialization completete!")
    info("- Next Step: Build the toolchain.")
    info("- 1. cd /mnt/physix/opt/physix")
    info("- 2. ./physix-tool -t 01-toolchain.json")
    info("------------------------------------")
    return SUCCESS


def do_toolchain_build(options):
    start=0
    if options.start_number:
        START = int(options.start_number)

    if os.path.exists("/tmp/physix-build.log"):
        CMD = ['mv', '/tmp/physix-build.log', '/mnt/physix/opt/logs.physix/']
        if (run_cmd(CMD))[1] != 0:
            ok("Relocated physix-build.log to /mnt/physix/opt/logs.physix/")
    logging.basicConfig(filename='/mnt/physix/opt/logs.physix/physix-build.log',
                            level=logging.DEBUG)
    info("build toolchain...")
    RECIPE_NAME = str(options.toolchain_conf)
    RECIPE = load_recipe(RECIPE_NAME)

    if pull_sources(RECIPE, "/mnt/physix/opt/sources.physix"):
        return FAILURE

    if verify_recipe_md5(RECIPE, "NON-CHRT"):
        return FAILURE

    if build_toolchain(RECIPE, "NON-CHRT", start):
        return FAILURE

    info("------------------------------------")
    info("- Toolchain Build Completete!")
    info("- Next Step: Build the Base System.")
    info("- ./physix-tool -s 02-base-system.json ")
    info("------------------------------------")
    return SUCCESS


def do_base_build(options):
    start=0
    if options.start_number:
        START = int(options.start_number)

    logging.basicConfig(filename='/mnt/physix/opt/logs.physix/physix-build.log',
                            level=logging.DEBUG)
    info("Building Base System...")
    RECIPE_NAME = str(options.base_conf)
    RECIPE = load_recipe(RECIPE_NAME)

    if pull_sources(RECIPE, "/mnt/physix/opt/sources.physix"):
        return FAILURE

    if verify_recipe_md5(RECIPE, "NON-CHRT"):
        return FAILURE

    if build_base(RECIPE, "NON-CHRT", start):
        return FAILURE

    info("------------------------------------")
    info("- Base System Build Completete!")
    info("- Next Step: Build the toolchain.")
    info("- 1. ./physix-tool -c 03-config-base.json")
    info("------------------------------------")
    return SUCCESS


def do_config_base(options):
    start=0
    if options.start_number:
        start = int(options.start_number)

    logging.basicConfig(filename='/mnt/physix/opt/logs.physix/physix-build.log',
                            level=logging.DEBUG)
    info("Configure Base System...")
    info("Building Base System...")
    RECIPE_NAME = str(options.configure_base_conf)
    RECIPE = load_recipe(RECIPE_NAME)
    if config_base_system(RECIPE, "NON-CHRT", start):
        return FAILURE

    info("------------------------------------")
    info("- Base System Configured!")
    info("- Next Steps:")
    info("- 1. Pull Utility sources:")
    info("      ./physix-tool -p 04-utilities.json")
    info("- 2. reboot ")
    info("------------------------------------")
    return SUCCESS


def do_build_recipe(options):
    start=0
    if options.start_number:
        start = int(options.start_number)

    logging.basicConfig(filename='/opt/logs.physix/physix-build.log',
                            level=logging.DEBUG)
    info("Building Recipe")
    RECIPE_NAME = str(options.build_recipe)
    RECIPE = load_recipe(RECIPE_NAME)
    if build_recipe(RECIPE, "CHRT", start):
        return FAILURE

    info("------------------------------------")
    info("- Build Complete")
    info("------------------------------------")
    return SUCCESS


def do_list_stack(options):
    conn = get_db_connection()
    if list_stack(conn):
        error("list_stack fail")
    conn.close()
    return SUCCESS



def do_pull_sources(options):
    """ "Determint path of sources.physix and call pull_sources() """
    context = 'NON-CHRT'
    dest = "/mnt/physix/opt/sources.physix"

    if not os.path.exists(dest):
        dest = "/opt/sources.physix"
        context = "CHRT"
        if not os.path.exists(dest):
            error("Pull Sources: Invalid Destination")
            return FAILURE

    info("Downloading Sources to: "+dest)
    recipe_name = str(options.pull_sources)
    recipe = load_recipe(recipe_name)
    if not pull_sources(recipe, dest):
        return FAILURE

    if not verify_recipe_md5(recipe, context):
        return FAILURE

    return SUCCESS
    

def main():

    parser = OptionParser()
    parser.add_option("-i", "--build-init", dest="build_conf",
                      help="Initialize system build process.", metavar="")
    parser.add_option("-t", "--build-toolchain", dest="toolchain_conf",
                      help="Build temp toolchain.", metavar="")
    parser.add_option("-s", "--build-base-system", dest="base_conf",
                      help="Build the Base System. ", metavar="")
    parser.add_option("-c", "--base-system-config", dest="configure_base_conf",
                      help="Configure Base system.", metavar="")
    parser.add_option("-b", "--build-recipe", dest="build_recipe",
                      help="Build Recipe", metavar="")
    parser.add_option("-a", "--start", dest="start_number",
                      help="build recipe starting at line number A", metavar="")
    parser.add_option("-z", "--stop", dest="stop_number",
                      help="build recipe no further than line number Z", metavar="")
    parser.add_option("-p", "--pull-sources", dest="pull_sources",
                      help="Download sources from from/for a recipe", metavar="")
    parser.add_option("-f", "--file-snopshot", dest="file_snap",
                      help="Record md5sum of all files under core systemd directoryes", metavar="")
    parser.add_option("-l", "--list-stack", action="store_true", dest="list_stack",
                      help="List state of system stack", metavar="")
    parser.add_option("-q", "--quiet",
                      action="store_false", dest="verbose", default=True,
                      help="don't print status messages to stdout")


    if 0 != os.geteuid():
        error("User not permitted. Exiting.")
        return FAILURE

    (options, args) = parser.parse_args()
    print(str(options))

    if options.build_conf:
        sys.exit(do_partition_init(options))

    if options.toolchain_conf:
        sys.exit(do_toolchain_build(options))

    if options.base_conf:
        sys.exit(do_base_build(options))

    if options.configure_base_conf:
        sys.exit(do_config_base(options))

    if options.build_recipe:
        sys.exit(do_build_recipe(options))

    if options.pull_sources:
        sys.exit(do_pull_sources(options))

    if options.list_stack:
        sys.exit(do_list_stack(options))



if __name__ == '__main__':
    main()

