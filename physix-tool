#!/usr/bin/python3
import os
import sys
import json
import sqlite3
import tarfile
import logging
import datetime
import subprocess
from signal import signal, SIGINT
from optparse import OptionParser

BUILDROOT = "/mnt/physix"
FAILURE = 1
SUCCESS = 0

def handler(signal_received, frame):
    ''' Handle SIGIN/CTRL-C '''
    print('SIGINT or CTRL-C detected. Exiting... ')
    sys.exit(0)

#---------------------------------------------
# DB Functions
#---------------------------------------------
def get_db_connection(chroot=''):
    ''' Return db connection object 
        Return None on error '''

    db_path = '/opt/.DB.physix'
    conn = None

    try:
        conn = sqlite3.connect(db_path)
    except Exception as e:
        error(str(e))
        return None
    return conn


def root_fs_type():
    ret_tpl = run_cmd(['lsblk', '-o', 'MOUNTPOINT,FSTYPE'])
    if validate(ret_tpl, "Determine root FS type"):
        return FAILURE
    std_out = ret_tpl[1]

    for line in std_out.split('\n'):
        split_line = line.split(' ')
        result = list(filter(lambda x: x != "", split_line))
        if len(result) != 2:
            continue
        if result[0] == '/':
            return result[1]


def get_name_current_stack():
    if 'btrfs' != root_fs_type():
        return 'STACK_0'

    ret_tpl = run_cmd(['btrfs', 'subvolume', 'show', '/'])
    if validate(ret_tpl, "btrfs subvolume show /"):
        return FAILURE
    std_out = ret_tpl[1]
    
    parsed_lst = std_out.split('\n')
    if parsed_lst[0]:
        return str(parsed_lst[0])
    else:
        return None


def index_already_exists(stack_name):
    ret_tpl = run_cmd(['btrfs', 'subvolume', 'list', '/'])
    if validate(ret_tpl, "btrfs subvolume list /"):
        return FAILURE
    std_out = ret_tpl[1]

    parsed_lst = std_out.split('\n')
    for entry in parsed_lst:
        datums = entry.split(' ')
        if len(datums) == 9:
            if str(stack_name) == str(datums[8]):
                return True
    return False


def get_snap_id(stack_name):
    ret_tpl = run_cmd(['btrfs', 'subvolume', 'list', '/'])
    if validate(ret_tpl, "btrfs subvolume list /"):
        return None
    std_out = ret_tpl[1]

    parsed_lst = std_out.split('\n')
    for entry in parsed_lst:
        datums = entry.split(' ')
        if len(datums) == 9:
            if str(stack_name) == str(datums[8]):
                return str(datums[1])
    return None 


def init_db_tables():
    """ Create initial STACK_0 Table and initialize it
        return SUCCESS/FAILURE """

    conn = None
    try:
        conn = sqlite3.connect('/mnt/physix/opt/.DB.physix')
    except Exception as e:
        error(str(e))
        return FAILURE 

    sql_create_init_stack = """ CREATE TABLE IF NOT EXISTS STACK_0 (
                                    ID integer PRIMARY KEY AUTOINCREMENT,
                                    TIME text NOT NULL,
                                    OP text NOT NULL,
                                    COMMITID text,
                                    SNAPID text,
                                    PKG text,
                                    SCRIPT text); """
    try:
        cur = conn.cursor()
        cur.execute(sql_create_init_stack, "")
        conn.commit()
    except Exception as e:
        error(str(e))
        return FAILURE

    
    sql = ''' INSERT INTO STACK_0 (TIME,OP,COMMITID,SNAPID,PKG,SCRIPT) VALUES(?,?,?,?,?,?) ''' 
    init_values = ("INIT", 'INIT', 'INIT', 'INIT', 'INIT','INIT')
    try:
        cur = conn.cursor()
        cur.execute(sql, init_values)
        conn.commit()
    except Exception as e:
        error(str(e))
        return FAILURE

    return SUCCESS


def date():
    return str(format(datetime.datetime.now()))


def exec_sql(conn, sql, data):
    try:
        cur = conn.cursor()
        cur.execute(sql, data)
        conn.commit()
    except Exception as e:
        error(str(e))
        return FAILURE
    return SUCCESS


def list_stack(conn):
    stack_name = get_name_current_stack()
    info("stack::"+str(stack_name))

    stack_lst = []
    try:
        cur = conn.cursor()
        cur.execute("SELECT * FROM "+stack_name)
        stack_lst = cur.fetchall()
    except Exception as e:
        error(e)
        return FAILURE

    info("Stack Size: "+str(len(stack_lst)))
    for i in range(len(stack_lst)-1, -1, -1):
        prim_key = str(stack_lst[i][0])
        date     = str(stack_lst[i][1])
        op       = str(stack_lst[i][2])
        commit   = str(stack_lst[i][3])
        snap     = str(stack_lst[i][4])
        pkg      = str(stack_lst[i][5])
        script   = str(stack_lst[i][6])

        listing = " ".join([prim_key, date, op, snap, pkg, script])
        print('{:<4s} {:<4s} {:<4s} {:<4s} {:<30s} {:<30s}'.format(prim_key, date, op, snap, pkg, script ))
    return SUCCESS


#---------------------------------------------
# INIT FUNCTIONS
#---------------------------------------------
def validate(rtn_tpl, msg, report=False):
    """ Log appropriate message based on return code"""
    rcode = int(rtn_tpl[0])
    if rcode == SUCCESS:
        if report == True:
            ok(msg)
        return SUCCESS
 
    error(msg)
    error("RTN:"+str(rtn_tpl[0]))
    error("stdout:"+str(rtn_tpl[1]))
    error("stderr:"+str(rtn_tpl[2]))
    return FAILURE


def info(msg):
    """ write info message to log """
    print("\033[0;33;48m [INFO] \033[0m " + msg)
    logging.info(msg)


def error(msg):
    """ write error message to log """
    msg = "\033[0;31;48m [ERROR] \033[0m " + msg
    print(msg)
    logging.error(msg)


# \e[92m[OK]\e[0m
def ok(msg):
    """ write success message to log """
    msg = "\033[0;32;48m [OK] \033[0m   " + msg
    print(msg)
    logging.info(msg)


def set_build_lock():
    if not os.path.exists('/run/lock/buildbox.lock'):
        rtn_tpl = run_cmd(['touch', '/run/lock/buildbox.lock'])
        return validate(rtn_tpl,"Set /run/lock/buildbox.lock")
    else:
        error("buildbox.lock Already set.")
        return FAILURE


def unset_build_lock():
    if os.path.exists('/run/lock/buildbox.lock'):
        rtn_tpl = run_cmd(['rm', '/run/lock/buildbox.lock'])
        return validate(rtn_tpl,"buildbox.lock removed")
    else:
        error("buildbox.lock not Set.")
        return FAILURE


def load_recipe(cfg):
    """ Read in recipe as dict """
    with open(cfg) as file_desc:
        return json.load(file_desc)


def load_physix_config(cfg):
    """ cfg : string """
    config = {}
    with open(cfg, "r") as file_desc:
        lines = file_desc.readlines()
        for line in lines:
            line = line.strip().strip().strip("\n")

            if line.startswith('#') or len(line) == 0:
                continue

            lst = line.split("=")
            if len(lst) != 2:
                error("Unexpected Format")

            cfg = str(lst[0])
            val = str(lst[1])
            config[cfg] = val
    return config


#---------------------------------------------
#---------------------------------------------
def verify_checker(config):
    """ config : {} """

    filesystem = config['CONF_ROOTPART_FS']
    mkfs  = "mkfs." + filesystem
    for tool in ['mkfs.fat', 'mkfs.ext2', mkfs, 'gcc', 'g++', 'make', 'gawk', 'bison', 'texi2any', 'parted']:
        ret_tpl = run_cmd(['which', tool])
        if validate(ret_tpl, "Check: "+ tool):
            return FAILURE

    root_dev = config["CONF_ROOT_DEVICE"]
    devlst = os.listdir("/dev")
    dev_count = sum(1 for ln in devlst if root_dev in ln)
    if dev_count > 1:
        msg = "".join(["Found Existing partition(s) on: /dev/", root_dev,
                       "Please remove them and restart this opperation"])
        error(msg)
        return FAILURE

    return SUCCESS


#---------------------------------------------
#---------------------------------------------
def create_partitions(config):
    """ config : {} """
    root_device = "/dev/" + config["CONF_ROOT_DEVICE"]
    rtn = root_device = root_device.strip("\n")

    of = 'of='+root_device
    ret_tpl = run_cmd(["dd", 'if=/dev/zero', of, 'bs=1M', 'count=5000'])
    if validate(ret_tpl, "Zero out beginning of device"):
        return FAILURE

    ret_tpl = run_cmd(['parted', root_device, 'mklabel', 'gpt'])
    if validate(ret_tpl, "Create Disk label"):
        return FAILURE

    # UEFI 1
    uefi_size = config["CONF_UEFI_PART_SIZE"].strip("\n")
    ret_tpl = run_cmd(["parted", root_device, "mkpart", "primary", "1", uefi_size])
    if validate(ret_tpl, "Create UEFI Partition"):
        return FAILURE

    # BOOT PART
    boot_size = config["CONF_BOOT_PART_SIZE"].strip("\n")
    boot_boundery = str(int(uefi_size) + int(boot_size))
    ret_tpl = run_cmd(['parted', root_device, "mkpart", "primary", uefi_size, boot_boundery])
    if validate(ret_tpl, "Create /boot Partition"):
        return FAILURE

    psize = config['CONF_PHYS_ROOT_PART_SIZE'].strip("\n")
    phys_boundery = str(int(boot_boundery) + int(psize))
    ret_tpl = run_cmd(['parted', root_device, "mkpart", "primary", boot_boundery, phys_boundery])
    if validate(ret_tpl, "Create ROOT Partition"):
        return FAILURE

    ret_tpl = run_cmd(['parted', root_device, 'set', '1', 'boot', 'on'])
    if validate(ret_tpl, "Boot Flag Set to "+root_device):
        return FAILURE

    return SUCCESS


#---------------------------------------------
#---------------------------------------------
def create_volumes(config):
    """ Create lvm volumes """

    system_root = "/dev/" + config["CONF_ROOT_DEVICE"].strip('\n')
    system_root = system_root + "3"
    ret_tpl = run_cmd(['pvcreate', '-ff', '-y', system_root])
    if validate(ret_tpl, "Physical Volume Create: "+system_root):
        return FAILURE

    vol_group_name = config["CONF_VOL_GROUP_NAME"].strip("\n")
    ret_tpl = run_cmd(['vgcreate', '-ff', vol_group_name, system_root])
    if validate(ret_tpl, ""):
        return FAILURE

    root_vol_size = str(config["CONF_LOGICAL_ROOT_SIZE"].strip('\n'))+"G"
    ret_tpl = run_cmd(['lvcreate', '--yes', '-L', root_vol_size, '-n', 'root', vol_group_name])
    if validate(ret_tpl, "Volume Create: root"):
        return FAILURE

    home_vol_size = str(config["CONF_LOGICAL_HOME_SIZE"].strip('\n')) + "G"
    ret_tpl = run_cmd(["lvcreate", '--yes', "-L", home_vol_size, '-n', 'home', vol_group_name])
    if validate(ret_tpl, "Volume Create: home"):
        return FAILURE

    var_vol_size = str(config["CONF_LOGICAL_VAR_SIZE"].strip('\n')) + "G"
    ret_tpl = run_cmd(["lvcreate", '--yes', "-L", var_vol_size, '-n', 'var', vol_group_name])
    if validate(ret_tpl, "Volume Create: var"):
        return FAILURE

    opt_vol_size = str(config["CONF_LOGICAL_OPT_SIZE"].strip('\n')) + "G"
    ret_tpl = run_cmd(["lvcreate", '--yes', "-L", opt_vol_size, '-n', 'opt', vol_group_name])
    if validate(ret_tpl, "Volume Create: opt"):
        return FAILURE

    tmp_vol_size = str(config["CONF_LOGICAL_TMP_SIZE"].strip('\n')) + "G"
    ret_tpl = run_cmd(["lvcreate", '--yes', "-L", tmp_vol_size, '-n', 'tmp', vol_group_name])
    if validate(ret_tpl, "Volume Create: opt"):
        return FAILURE

    return SUCCESS


#---------------------------------------------
#---------------------------------------------
def format_volumes(config):
    """ Format lvm volumes and partitions """

    filesystem = config['CONF_ROOTPART_FS']
    mkfs_cmd  = "mkfs." + filesystem

    system_root = "/dev/" + config["CONF_ROOT_DEVICE"]
    vol_group_name = config["CONF_VOL_GROUP_NAME"]

    part1 = system_root + "1"
    ret_tpl = run_cmd(['mkfs.fat', part1])
    if validate(ret_tpl, "mkfs.fat: " + part1):
        return FAILURE

    part2 = system_root + "2"
    ret_tpl = run_cmd(['mkfs.ext2', part2])
    if validate(ret_tpl, "mkfs.ext2: " + part2):
        return FAILURE

    physix_root = "/dev/mapper/" + vol_group_name + "-root"
    ret_tpl = run_cmd([mkfs_cmd, physix_root])
    if validate(ret_tpl, mkfs_cmd+":"+physix_root):
        return FAILURE

    physix_home = "/dev/mapper/" + vol_group_name + "-home"
    ret_tpl = run_cmd([mkfs_cmd, physix_home])
    if validate(ret_tpl, mkfs_cmd+":"+physix_home):
        return FAILURE

    physix_var = "/dev/mapper/" + vol_group_name + "-var"
    ret_tpl = run_cmd([mkfs_cmd, physix_var])
    if validate(ret_tpl, mkfs_cmd+""+physix_var):
        return FAILURE

    physix_opt = "/dev/mapper/" + vol_group_name + "-opt"
    ret_tpl = run_cmd([mkfs_cmd, physix_opt])
    if validate(ret_tpl, mkfs_cmd+":"+ physix_opt):
        return FAILURE

    physix_tmp = "/dev/mapper/" + vol_group_name + "-tmp"
    ret_tpl = run_cmd([mkfs_cmd, physix_tmp])
    if validate(ret_tpl, mkfs_cmd+":"+physix_tmp):
        return FAILURE

    return SUCCESS


def get_subvol_id(mount_point, stack_name):
    ret_tpl = run_cmd(['btrfs', 'subvolume', 'list', mount_point])
    if validate(ret_tpl, "List subvolumes for mountpoint:" + mount_point):
        return None

    output = ret_tpl[1]
    lst = output.split(' ')
    if len(lst) == 9:
        vol_id = str(lst[1])
        return vol_id
    else:
        error("Unexpected String size.")
        return None


#---------------------------------------------
#--------------------------------------------
def mount_volumes(config):
    """ Mount volumes and partitions """
    filesystem = config['CONF_ROOTPART_FS']
    vol_group_name = config["CONF_VOL_GROUP_NAME"]

    if not os.path.exists(BUILDROOT):
        os.mkdir(BUILDROOT, 755)

    volume_root = "/dev/mapper/" + vol_group_name + "-root"
    ret_tpl = run_cmd(['mount', volume_root, BUILDROOT])
    if validate(ret_tpl, "Mount: "+volume_root):
        return FAILURE

    if filesystem == 'btrfs':
        btrfs_subvolume = BUILDROOT + "/" + "STACK_0"
        ret_tpl = run_cmd(['btrfs', 'subvolume', 'create', btrfs_subvolume])
        if validate(ret_tpl, "Create  subvolume: STACK_0 on physix-root"):
            return FAILURE

        vol_id = get_subvol_id(BUILDROOT, "STACK_0")
        if vol_id == None:
            return FAILURE
        ret_tpl = run_cmd(['btrfs', 'subvolume', 'set-default', vol_id, BUILDROOT])
        if validate(ret_tpl, "btrfs subvolume set-default:"+vol_id):
             return FAILURE

        ret_tpl = run_cmd(['umount', '/mnt/physix'])
        if validate(ret_tpl, "unmount /mnt/physix"):
            return FAILURE

        volume_root = "/dev/mapper/" + vol_group_name + "-root"
        ret_tpl = run_cmd(['mount', '-t', 'btrfs', '-o', 'subvol=STACK_0', volume_root, '/mnt/physix'])
        if validate(ret_tpl, "Mount physix-root subvolume: STACK_0"):
            return FAILURE

    mnt_point = BUILDROOT + "/home"
    os.mkdir(mnt_point, 0o755)
    volume_home = "/dev/mapper/" + vol_group_name + "-home"
    ret_tpl = run_cmd(['mount', volume_home, mnt_point])
    if validate(ret_tpl, "Mount: " + volume_home):
        return FAILURE

    var = BUILDROOT + "/var"
    os.mkdir(var, 0o755)
    volume_var = "/dev/mapper/" + vol_group_name + "-var"
    mnt_point = BUILDROOT + "/var"
    ret_tpl = run_cmd(['mount', volume_var, mnt_point])
    if validate(ret_tpl, "Mount: " + volume_var):
        return FAILURE

    opt = BUILDROOT + "/opt"
    os.mkdir(opt, 0o755)
    volume_opt = "/dev/mapper/" + vol_group_name + "-opt"
    mnt_point = BUILDROOT + "/opt"
    ret_tpl = run_cmd(['mount', volume_opt, mnt_point])
    if validate(ret_tpl, "Mount: " + volume_opt):
        return FAILURE

    boot = BUILDROOT + "/boot"
    os.mkdir(boot, 0o755)
    boot_part = "/dev/" + config["CONF_ROOT_DEVICE"].strip('\n') + "2"
    ret_tpl = run_cmd(['mount', boot_part, boot])
    if validate(ret_tpl, "Mount: " + boot_part):
        return FAILURE

    tmp = BUILDROOT + "/tmp"
    os.mkdir(tmp, 0o755)
    volume_tmp = "/dev/mapper/" + vol_group_name + "-tmp"
    mnt_point = BUILDROOT + "/tmp"
    ret_tpl = run_cmd(['mount', volume_tmp, mnt_point])
    if validate(ret_tpl, "Mount: " + volume_tmp):
        return FAILURE

    return SUCCESS


def get_sources_prefix(context):
    if context == "CHRT":
        return '/opt/sources.physix/'
    elif context == "NON-CHRT":
        return '/mnt/physix/opt/sources.physix/'
    else:
        error("get_sources_prefix: Unknown context")
        return False


def get_physix_prefix(context):
    if context == "CHRT":
        return '/opt/physix/'
    elif context == "NON-CHRT":
        return '/mnt/physix/opt/physix/'
    else:
        error("get_physix_prefix: Unknown context")
        return False


def verify_file_md5(fname, rmd5, context):
    prefix = get_sources_prefix(context)
    fname = prefix + fname

    ret_tpl = run_cmd(['md5sum', fname])
    if ret_tpl[0] == 0:
        cmpr_md5 = ret_tpl[1].split(' ')[0]
        cmpr_md5 = cmpr_md5.replace("b'", "")
        if cmpr_md5 == rmd5:
            ok("MD5 Verified: "+fname+" : "+cmpr_md5)
            return True
        else:
            error("MD5 Verified: "+fname+" : "+cmpr_md5 +":"+rmd5)
    return False


#----------------------------------------------------
#----------------------------------------------------
def verify_recipe_md5(recipe, context):
    for i in range(len(recipe['build_queue'])):
        element = recipe[str(i)]
        sources = element['sources']

        for url in sources.keys():
            rmd5 = sources[url]
            archv_name = url.split("/")[-1]

            if not verify_file_md5(archv_name, rmd5, context):
                return FAILURE

    return SUCCESS


#----------------------------------------------------
#---------------------------------------------------
def pull_sources(recipe, dest):
    """ Download sources """
    dir_prefix = '--directory-prefix=' + dest
    rsize = len(recipe['build_queue'])

    if not os.path.exists(dest):
        os.mkdir(dest, 0o755)
        if not os.path.exists(dest):
            error("Destination Path Creation Failed:" + dest)

    pull_lst = []
    for i in range(rsize):
        sources = recipe[str(i)]["sources"]
        for key in sources.keys():
            pull_lst.append(key)

    for url in pull_lst:
        if url:
            ret_tpl = run_cmd(['wget', '-q', '--continue', dir_prefix, url])
            if validate(ret_tpl, "Download: "+url, True):
                return FAILURE

    return SUCCESS


def setup_build_env(element, context):
    """ Setup build directory. Returns boolean on success/failure """
    src_prefix = get_sources_prefix(context)
    if src_prefix == False:
        return FAILURE
    bb_path = os.path.join(src_prefix, "BUILDBOX")

    if not refresh_build_box(context):
        error("refresh_build_box")
        return FAILURE

    physix_prefix = get_physix_prefix(context)
    if physix_prefix == False:
        return FAILURE

    include = os.path.join(physix_prefix, "include.sh")
    ret_tpl = run_cmd(['cp', include, bb_path])
    if validate(ret_tpl, 'Copy include.sh to BUILDBOX'):
        return FAILURE

    buildconf =  os.path.join(physix_prefix, "physix.conf")
    ret_tpl = run_cmd(['cp', buildconf, bb_path])
    if validate(ret_tpl, 'Copy physix.conf to BUILDBOX'):
        return FAILURE

    for patch in element["patches"]:
        patch_path = os.path.join(src_prefix, patch)
        ret_tpl = run_cmd(['cp', patch_path, bb_path])
        if validate(ret_tpl, 'Copy patch to BUILDBOX'):
            return FAILURE

    for archive in element["archives"]:
        #archive_path = src_path + archive
        archive_path = os.path.join(src_prefix, archive)
        ret_tpl = run_cmd(['cp', archive_path, bb_path])
        if validate(ret_tpl, 'Copy archive to BUILDBOX'):
            return FAILURE
    return SUCCESS

#---------------------------------------------
#--------------------------------------------
def setup(config):
    """ Setup environment for system build """
    if not os.path.exists(BUILDROOT+"/opt"):
        os.mkdir(BUILDROOT+"/opt", 755)
    if not os.path.exists(BUILDROOT+"/opt/logs.physix"):
        os.mkdir(BUILDROOT+"/opt/logs.physix", 777)
    if not os.path.exists(BUILDROOT+"/opt/sources.physix"):
        os.mkdir(BUILDROOT+"/opt/sources.physix", 770)

    # First find bash
    ret_tpl = run_cmd(['ln', '-sfv', '/usr/bin/bash', '/usr/bin/sh'])
    if validate(ret_tpl, "link bash to 'sh/bash'"):
        return FAILURE

    # First find gawk
    ret_tpl = run_cmd(['ln', '-sfv', '/usr/bin/gawk', '/usr/bin/awk'])
    if validate(ret_tpl, "link gawk to 'awk/gawk'"):
        return FAILURE

    # First find bison
    ret_tpl = run_cmd(['ln', '-sfv', '/usr/bin/bison', '/usr/bin/yacc'])
    if validate(ret_tpl, "link gawk to 'yacc/bison'"):
        return FAILURE

    tools = BUILDROOT+"/tools"
    ret_tpl = run_cmd(['ln', '-sfv', tools, '/'])
    if validate(ret_tpl, "link tools dir"):
        return FAILURE

    (rtn, out, err) = run_cmd(['grep', 'physix', '/etc/passwd'])
    if int(rtn) != 0:
        ret_tpl = run_cmd(['useradd', '-s', '/bin/bash', '-m', 'physix'])
        if validate(ret_tpl, "useradd physix"):
            return FAILURE

    src = str(os.getcwd()) + "/build-scripts/03-base-config/configs/physix-bashrc"
    dest = "/home/physix/.bashrc"
    ret_tpl = run_cmd(['cp', src, dest])
    if validate(ret_tpl, "set physix user's .bashrc file"):
        return FAILURE

    tools_dir = BUILDROOT + "/tools"
    os.mkdir(tools_dir, 0o755)
    ret_tpl = run_cmd(['chown', '-v', 'physix', tools_dir])
    if validate(ret_tpl, "chown "+tools_dir):
        return FAILURE

    ret_tpl = run_cmd(['chmod', '750', tools_dir])
    if validate(ret_tpl, "chmod 770 "+tools_dir):
        return FAILURE

    sources_dir = BUILDROOT + "/opt/sources.physix"
    ret_tpl = run_cmd(['chown', '-v', 'physix', sources_dir])
    if validate(ret_tpl, "chown "+sources_dir):
        return FAILURE

    ret_tpl = run_cmd(['chmod', '750', sources_dir])
    if validate(ret_tpl, "chmod 750 "+sources_dir):
        return FAILURE

    ret_tpl = run_cmd(['mv', os.getcwd(), '/mnt/physix/opt/'])
    if validate(ret_tpl, "Move physix repo to /mnt/physix/opt/"):
        return FAILURE

    return SUCCESS 

#---------------------------------------------
#---------------------------------------------
def build_toolchain(recipe, context, build_num=0):
    """ Build the temorary toolchain from recipe """

    buildq = recipe['build_queue']
    for i in range(build_num, len(buildq)):
        build_id = str(buildq[i])
        element  = recipe[build_id]

        stat = " ".join(["Build [", str(i), "/", str(len(buildq)), "] Toolchain" ] )
        info(stat)

        if setup_build_env(element, context):
            return FAILURE

        ''' Fails on error '''
        if unpack(element, context):
            return FAILURE

        """ Dir name of First tarball in list is passed as arg to the 
            build script """
        build_src = ''
        if element["archives"] != []:
            bsp = os.path.join(get_sources_prefix(context), str(element["archives"][0]))
            build_src = top_most_dir(bsp)

        subcmd = os.path.join('/mnt/physix/opt/physix/build-scripts/',
                              str(element["group"]),
                              str(element["build_script"]))
        subcmd = " ".join([subcmd, build_src])
        cmd = ['su', 'physix', '-c', subcmd]

        info("Building " + str(cmd))
        ret_tpl = run_cmd_log(cmd, str(element["build_script"]), "")
        if validate(ret_tpl, "Build: " + str(cmd), True):
            return FAILURE

    return SUCCESS


#---------------------------------------------
#---------------------------------------------
def build_recipe(recipe, context, build_num):
    """ Build recipe """

    buildq = recipe['build_queue']
    for i in range(build_num, len(buildq)):
        build_id = str(buildq[i])
        element  = recipe[build_id]

        stat = " ".join(["Building [", str(i), "/", str(len(buildq)), "]"])
        info(stat)

        if set_build_lock():
            return FAILURE

        if setup_build_env(element, context):
            return FAILURE

        unpack(element, context)

        """ Dir name of First tarball in list, is passed as arg to the 
            build script """
        if element["archives"] != []:
            bsp = "/opt/sources.physix/"+ str(element["archives"][0])
            build_src = top_most_dir(bsp)
        else:
            build_src = ''

        subcmd = os.path.join('/opt/physix/build-scripts/',
                              str(element["group"]),
                              str(element["build_script"]))
        cmd = [subcmd, build_src]

        info("Executing Build: " + "[" + str(build_num) + "] " + str(cmd))
        #os.chdir('/opt/sources.physix/BUILDBOX')
        ret_tpl = run_cmd_log(cmd, str(element["build_script"]), context)
        #os.chdir('/opt/physix')
        if validate(ret_tpl, "Build: "+str(cmd), True):
            unset_build_lock()
            return FAILURE

        db = get_db_connection()
        if db:
            stack_name = get_name_current_stack()
            entry = (date(), 'BUILD', '123456', '', build_src, str(element["build_script"]))
            sql = "INSERT INTO "+ stack_name + " (TIME,OP,COMMITID,SNAPID,PKG,SCRIPT) VALUES(?,?,?,?,?,?) "
            if exec_sql(db, sql, entry):
                error("DB: Failed to insert entry")
                return FAILURE
            db.close()

        if unset_build_lock():
            return FAILURE



#---------------------------------------------
# Input: string - recipe : Recipe file path
# Input: string - chroot or non chroot context
# Input: int - Start building from recipe at line number
#---------------------------------------------
def build_base(recipe, context, build_num):
    """ Build base system from recipe """

    if build_num == 0:
        cmd = ['/mnt/physix/opt/physix/build-scripts/02-base/2.000-base-build-prep.sh']
        ret_tpl = run_cmd_log(cmd, "2.000-base-build-prep.sh", "")
        if validate(ret_tpl, "Build: " + str(cmd)):
            return FAILURE

    for i in range(build_num, len(recipe['build_queue'])):
        buildq = recipe['build_queue']
        build_id = str(buildq[i])
        element  = recipe[build_id]

        stat = " ".join(["Building [", str(i), "/", str(len(recipe['build_queue'])), "] Base System" ] )
        info(stat)

        if setup_build_env(element, context):
            error("Failed to stup build_env")
            return FAILURE

        if unpack(element, context):
            error("Failed to unpack")
            return FAILURE

        """ Dir name of First tarball in list, is passed as arg to the 
            build script """
        if element["archives"] != []:
            bsp = "/mnt/physix/opt/sources.physix/"+ str(element["archives"][0])
            build_src = top_most_dir(bsp)
        else:
            build_src = ''

        cmd = ['/mnt/physix/opt/physix/build-scripts/02-base/000-chroot_stub.sh',
               str(element["build_script"]),
               build_src]
        info("Executing Build: " + "[" + str(build_num) + "] " + str(cmd))
        ret_tpl = run_cmd_log(cmd, str(element["build_script"]), "")
        if validate(ret_tpl, "Build: " + str(cmd), True):
            return FAILURE


#---------------------------------------------
# Sees system as /mnt/physix/opt/physix
#---------------------------------------------
def config_base_system(recipe, context, build_num):
    """ Configure the base system from recipe """

    for i in range(build_num, len(recipe['build_queue'])):
        element = recipe[str(i)]

        stat = " ".join(["Building [", str(i), "/", str(len(recipe['build_queue'])), "] Config Base System" ])
        info(stat)

        if setup_build_env(element, context):
            error("Failed to stup build_env")
            return False

        """ Fails on error """
        if unpack(element, context):
            return FAILURE

        """ Dir name of First tarball in list, is passed as arg to the 
            build script """
        if element["archives"] != []:
            bsp = "/mnt/physix/opt/sources.physix/"+ str(element["archives"][0])
            build_src = top_most_dir(bsp)
        else:
            build_src = ''

        cmd = ['/mnt/physix/opt/physix/build-scripts/03-base-config/000-conf_chrrot_stub.sh',
               str(element["build_script"]),
               build_src]
        info("Executing Build: " + "[" + str(build_num) + "] " + str(cmd))
        ret_tpl = run_cmd_log(cmd, str(element["build_script"]), "")
        if validate(ret_tpl, "Build: "+str(cmd), True):
            return FAILURE

    """ Special case for user to set password without logging"""
    cmd = ['/mnt/physix/opt/physix/build-scripts/03-base-config/000-conf_chrrot_stub.sh',
           '3.111-set-passwd.sh']
    run_cmd_live(cmd)


#---------------------------------------------
#---------------------------------------------
def run_cmd_log(cmd, name, context):
    """ run command and log I/O to log file  """
    date = format(datetime.datetime.now())
    date = date.replace(":", "-").replace(" ", "-")
    log_name = date + "-" + name
    rtn = FAILURE

    if context == "CHRT":
        log_path = "/opt/logs.physix/" + log_name
    else:
        log_path = "/mnt/physix/opt/logs.physix/" + log_name

    with open(log_path, "w") as file_desc:
        try:
            p = subprocess.run(cmd, stdout=file_desc, stderr=file_desc)
            rtn = int(p.returncode)
        except Exception as exc:
            error("[ERROR] Opperation Failed:"+str(exc)),

    return (rtn, "", "")


#---------------------------------------------
#---------------------------------------------
def run_cmd(cmd):
    """ Run command, return caputured I/O Streams """
    out = ''
    err = ''
    try:
        p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        rtn = int(p.returncode)
        out = str(p.stdout.decode('utf-8'))
        err = str(p.stderr.decode('utf-8'))
    except Exception as exc:
        error("[Exceotion] Opperation Failed:\n "+str(exc))

    rtn = (int(rtn), str(out), str(err))
    #info("Returning:" + str(rtn))
    return rtn

#-----------------------------------------------------
#-----------------------------------------------------
def run_cmd_live(cmd):
    """ run commmand, don't capture output  """
    try:
        proc = subprocess.run(cmd)
        rtn = int(proc.returncode)
    except Exception as exc:
        error("[ERROR] run_cmd Execption."+str(exc)),
    return (rtn, "", "")


#-----------------------------------------------------
# Input: string - path to archive
# Output: string -  top most directory from archive
#-----------------------------------------------------
def top_most_dir(archive_path):
    """ Return name of directory encapsolated in the tar archive """
    archive_path = archive_path.strip().strip("\n")
    if not os.path.exists(archive_path):
        error("Expected path does not exist: " + archive_path)
    with tarfile.open(archive_path, mode='r') as archive:
        tmd = str(os.path.commonprefix(archive.getnames()))
        ''' Sometimes a path is returned '''
        tmd_lst = tmd.split("/")
        name_lst = list(filter(len, tmd_lst))
        return str(name_lst[0])



def common_prefix(archive_name, context):
    src_prefix = get_sources_prefix(context)
    tmpdir = src_prefix + "BUILDBOX/tmp/"
    p = src_prefix + "BUILDBOX/" + archive_name
    q = tmpdir + archive_name

    if os.path.exists(tmpdir):
        run_cmd(['rm', 'r', tmpdir])
    run_cmd(['mkdir', tmpdir])

    if ('tar' in archive_name) or ('tgz' in archive_name):
        ret_tpl = run_cmd(['tar', 'xf', p, '-C', tmpdir])
        if not validate(ret_tpl, 'unpack to buildbox :' + archive_name):
            return False
    elif 'bz2' in archive:
        ''' Not a tar arvhive, but a straight bz2 compressed file '''
        ret_tpl = run_cmd(['cp', p, q])
        if not validate(ret_tpl, 'cp bz2 to tmp'):
            return False
        ret_tpl = run_cmd(['bunzip2', '-dk', q])
        if not validate(ret_tpl, 'bunzip2: ' + q):
            return False


    lst = os.listdir(tmpdir)
    return lst


#---------------------------------------------
#---------------------------------------------
def refresh_build_box(context):
    """ Remove and Re-create BUILDBOX """

    prefix = get_sources_prefix(context)
    bb_path = prefix + "BUILDBOX"

    if os.path.exists(bb_path):
        ret_tpl = run_cmd(['rm', '-r', bb_path])
        validate(ret_tpl, '')

        os.mkdir(bb_path, 0o700)
        ret_tpl = run_cmd(['mkdir', '-p', bb_path])
        validate(ret_tpl, "mkdir bb_path: " + bb_path)

        ret_tpl = run_cmd(['chown', 'physix:root', bb_path])
        validate(ret_tpl, "chown physix " + bb_path)
    else:
        os.mkdir(bb_path, 0o700)
        ret_tpl = run_cmd(['chown', 'physix:root', bb_path])
        validate(ret_tpl, "chown physix " + bb_path)

    return True


#---------------------------------------------
# This is hard to read. re-write better
# input: element:dict, context:string
# output: list of directory names from extracted tarbballs
#---------------------------------------------
def unpack(element, context):
    """ Move extract archives, and patches to BUILDBOX dir """
    dir_list = []
    archive_list = []

    if element['archives'] == []:
        return []

    # Archives are stored in 1 or 2 paths, depending on
    # whether executed in chrooted or non-chrooted context
    src_path = get_sources_prefix(context)
    bb_path = src_path + "BUILDBOX/"

    if not os.path.exists(bb_path):
        error("Build Env Nnt Found")
        return FAILURE

    for archive in element["archives"]: 
        info('Unpacking:'+archive)
        archive_path = bb_path + archive

        if not os.path.exists(archive_path):
            error("Archive not found in BUILDBOX: "+archive_path)
            return FAILURE

        if ('tar' in archive) or ('tgz' in archive):
            ret_tpl = run_cmd(['tar', 'xf', archive_path, '-C', bb_path])
            if validate(ret_tpl, 'unpack to buildbox :' + archive_path):
                error("Tar Failure")
                return FAILURE
        elif 'bz2' in archive:
            ''' Not a tar arvhive, but a straight bz2 compressed file '''
            ret_tpl = run_cmd(['bunzip2', '-dk', archive_path])
            if validate(ret_tpl, 'bunzip2: ' + archive_path):
                error("unzip failure")
                return FAILURE

    # ASSIGN OWNERSHIP TO 'physix'
    ret_tpl = run_cmd(['chown', '--recursive', 'physix:root', bb_path])
    if validate(ret_tpl, "chown bbox"):
        error("Failed to chown BUILDBOX")
        return FAILURE

    return SUCCESS


def do_partition_init(options):
    logging.basicConfig(filename='/tmp/physix-build.log', level=logging.DEBUG)
    
    BUILD_CONFIG = load_physix_config(options.physix_conf)

    # rename sysreq_check
    if verify_checker(BUILD_CONFIG):
        error("Systemd Requirement check")
        return FAILURE
    ok("Systemd Requirement check")

    info("Creating Partitions")
    if create_partitions(BUILD_CONFIG):
        error("Creating Partitions")
        return FAILURE
    ok("Creating Partitions")

    info("Creating Volumes")
    if create_volumes(BUILD_CONFIG):
        error("Creating Volumes")
        return FAILURE
    ok("Create Volumes")

    info("Formating Volumes")
    if format_volumes(BUILD_CONFIG):
        error("Formating Volumes")
        return FAILURE
    ok("Format Volumes")

    info("Mounting Volumes")
    if mount_volumes(BUILD_CONFIG):
        error("Mounting Volumes")
        return FAILURE
    ok("Mounting Volumes")

    if setup(BUILD_CONFIG):
        return FAILURE

    info("------------------------------------")
    info("- Build initialization completete!")
    info("- Next Step: Build the toolchain.")
    info("- 1. cd /mnt/physix/opt/physix")
    info("- 2. ./physix-tool -p 01-toolchain.json")
    info("- 3. ./physix-tool -t 01-toolchain.json")
    info("------------------------------------")
    return SUCCESS


def do_toolchain_build(options):
    start=0
    if options.start_number:
        start = int(options.start_number)

    if os.path.exists("/tmp/physix-build.log"):
        CMD = ['mv', '/tmp/physix-build.log', '/mnt/physix/opt/logs.physix/']
        if (run_cmd(CMD))[1] != 0:
            ok("Relocated physix-build.log to /mnt/physix/opt/logs.physix/")
    logging.basicConfig(filename='/mnt/physix/opt/logs.physix/physix-build.log',
                            level=logging.DEBUG)
    info("build toolchain...")
    RECIPE_NAME = str(options.toolchain_conf)
    RECIPE = load_recipe(RECIPE_NAME)

    if verify_recipe_md5(RECIPE, "NON-CHRT"):
        error("verify_recipe_md5")
        return FAILURE

    if build_toolchain(RECIPE, "NON-CHRT", start):
        return FAILURE

    info("------------------------------------")
    info("- Toolchain Build Completete!")
    info("- Next Step: Build the Base System.")
    info("- ./physix-tool -p 02-base-system.json")
    info("- ./physix-tool -s 02-base-system.json")
    info("------------------------------------")
    return SUCCESS


def do_base_build(options):
    start=0
    if options.start_number:
        start = int(options.start_number)

    logging.basicConfig(filename='/mnt/physix/opt/logs.physix/physix-build.log',
                            level=logging.DEBUG)
    info("Building Base System...")
    RECIPE_NAME = str(options.base_conf)
    RECIPE = load_recipe(RECIPE_NAME)

    if verify_recipe_md5(RECIPE, "NON-CHRT"):
        error("verify_recipe_md5")
        return FAILURE

    if build_base(RECIPE, "NON-CHRT", start):
        return FAILURE

    info("------------------------------------")
    info("- Base System Build Completete!")
    info("- Next Step: Build the toolchain.")
    info("- 1. ./physix-tool -c 03-config-base.json")
    info("------------------------------------")
    return SUCCESS


def do_config_base(options):
    start=0
    if options.start_number:
        start = int(options.start_number)

    logging.basicConfig(filename='/mnt/physix/opt/logs.physix/physix-build.log',
                            level=logging.DEBUG)
    info("Configure Base System...")
    info("Building Base System...")
    RECIPE_NAME = str(options.configure_base_conf)
    RECIPE = load_recipe(RECIPE_NAME)
    if config_base_system(RECIPE, "NON-CHRT", start):
        return FAILURE

    if init_db_tables():
        error("Initialization of DB tables")
        return FAILURE

    info("------------------------------------")
    info("- Base System Configured!")
    info("- Next Steps:")
    info("- 1. Pull Utility sources:")
    info("      ./physix-tool -p 04-utilities.json")
    info("- 2. reboot ")
    info("------------------------------------")
    return SUCCESS


def do_build_recipe(options):
    start=0
    if options.start_number:
        start = int(options.start_number)

    logging.basicConfig(filename='/opt/logs.physix/physix-build.log',
                            level=logging.DEBUG)
    info("Building Recipe")
    RECIPE_NAME = str(options.build_recipe)
    RECIPE = load_recipe(RECIPE_NAME)
    if build_recipe(RECIPE, "CHRT", start):
        return FAILURE

    info("------------------------------------")
    info("- Build Complete")
    info("------------------------------------")
    return SUCCESS


def do_list_stack(options):
    conn = get_db_connection()
    if list_stack(conn):
        error("list_stack failed")
    conn.close()
    return SUCCESS


def do_pull_sources(options):
    """ "Determint path of sources.physix and call pull_sources() """
    context = 'NON-CHRT'
    dest = "/mnt/physix/opt/sources.physix"

    if not os.path.exists(dest):
        dest = "/opt/sources.physix"
        context = "CHRT"
        if not os.path.exists(dest):
            error("Pull Sources: Invalid Destination")
            return FAILURE

    info("Downloading Sources to: "+dest)
    recipe_name = str(options.pull_sources)
    recipe = load_recipe(recipe_name)
    if not pull_sources(recipe, dest):
        return FAILURE

    if not verify_recipe_md5(recipe, context):
        return FAILURE

    return SUCCESS


def name_is_valid(name):
    if '-' in name:
        error("Snapshot Name can not contain '-' character")
        return False

    if name[0].isdigit():
        error("Snatpshot Name can not start with numerical digit")
        return False

    return True


def do_list_snapshots():
    mntpoint = '/opt/.tmp/mnt/'

    if 'btrfs' != root_fs_type():
        error("File system snapshots are not available for " + str(root_fs_type()))
        return FAILURE

    if not os.path.exists(mntpoint):
        ret_tpl = run_cmd(['mkdir', '-p', mntpoint])
        if validate(ret_tpl, "mkdir "+mntpoint):
            return FAILURE

    # Just in case it is already mounted.
    ret_tpl = run_cmd(['umount', mntpoint])

    # Mount the root of the FS
    ret_tpl = run_cmd(['mount', '-o', 'subvolid=5', '/dev/mapper/physix-root', mntpoint])
    if validate(ret_tpl, "Mount physix-root to tmp mount point"):
        return FAILURE

    dir_listing = os.listdir(mntpoint)
    print("Available Snapshots:")
    for snap_name in dir_listing:
        print ("  "+snap_name)

    ret_tpl = run_cmd(['umount', mntpoint])
    if validate(ret_tpl, "Mount physix-root to tmp mount point"):
        return FAILURE


def do_snapshot(options):
    mntpoint = '/opt/.tmp/mnt/'
    snap_name = options.snapshot

    if 'btrfs' != root_fs_type():
        error("File system snapshots are not available for " + str(root_fs_type()))
        return FAILURE

    if not name_is_valid(snap_name):
        return FAILURE

    if not os.path.exists(mntpoint):
        ret_tpl = run_cmd(['mkdir', '-p', mntpoint])
        if validate(ret_tpl, "mkdir "+mntpoint):
            return FAILURE

    db  = get_db_connection()    
    if db:
        curr_stack = get_name_current_stack()
    else:
        error("DB connection == None")
        return FAILURE

    if index_already_exists(snap_name):
        error("Stack: "+snap_name+" Already Exits.")
        return FAILURE

    # Just in case it is already mounted.
    ret_tpl = run_cmd(['umount', mntpoint])

    # Mount the root of the FS 
    ret_tpl = run_cmd(['mount', '-o', 'subvolid=5', '/dev/mapper/physix-root', mntpoint])
    if validate(ret_tpl, "Mount physix-root to tmp mount point"):
        return FAILURE

    curr_stack_path = mntpoint + curr_stack
    snap_stack_path = mntpoint + snap_name
    ret_tpl = run_cmd(['btrfs', 'subvolume', 'snapshot', curr_stack_path, snap_stack_path])
    if validate(ret_tpl, "Record Snapshot:"+snap_name):
        ret_tpl = run_cmd(['umount', mntpoint])
        validate(ret_tpl, "umount mntpoint")
        return FAILURE

    #TODO: implement get_commit_id, so we can stop using 123456
    entry = (date(), 'SNAPSHOT', '123456', snap_name, '', '')
    sql = "INSERT INTO "+ curr_stack + " (TIME,OP,COMMITID,SNAPID,PKG,SCRIPT) VALUES(?,?,?,?,?,?) "
    if exec_sql(db, sql, entry):
        error("DB: Failed to record snapshot to stack"+curr_stack)
        return FAILURE
 
    sql_create_table = " CREATE TABLE IF NOT EXISTS "+ snap_name  +" ( \
                                ID integer PRIMARY KEY AUTOINCREMENT,  \
                                TIME text NOT NULL,                    \
                                OP text NOT NULL,                      \
                                COMMITID text,                         \
                                SNAPID text,                           \
                                PKG text,                              \
                                SCRIPT text); "
    if exec_sql(db, sql_create_table, ""):
        error("DB: Failed to record snapshot:"+snap_name)
        return FAILURE

    sql_copy_table = "INSERT INTO "+ snap_name +" SELECT * FROM " + curr_stack + ";"
    info(sql_copy_table)
    if exec_sql(db, sql_copy_table, ""):
        error("DB: Failed to copy data from curr_tack to new snapshot")
        return FAILURE

    ret_tpl = run_cmd(['umount', mntpoint])
    if validate(ret_tpl, "umount mntpoint after taking snapshot"):
        return FAILURE

    return SUCCESS


def do_set_default_snapshot(options):
    ''' Set the FS snapshot to boot from during the next reboot '''
    snap_name = options.defsnap

    snap_id = get_snap_id(snap_name)
    if snap_id == None:
        return FAILURE

    ret_tpl = run_cmd(['btrfs', 'subvolume', 'set-default', snap_id, '/'])
    if validate(ret_tpl, "Set Default Snapshot:"+snap_name, True):
        return FAILURE

    info("Next reboot will boot from: "+snap_name)
    return SUCCESS


def main():

    parser = OptionParser()
    parser.add_option("-i", "--build-init", dest="physix_conf",
                      help="Initialize system build process.", metavar="")
    parser.add_option("-t", "--build-toolchain", dest="toolchain_conf",
                      help="Build temp toolchain.", metavar="")
    parser.add_option("-s", "--build-base-system", dest="base_conf",
                      help="Build the Base System. ", metavar="")
    parser.add_option("-c", "--base-system-config", dest="configure_base_conf",
                      help="Configure Base system.", metavar="")
    parser.add_option("-b", "--build-recipe", dest="build_recipe",
                      help="Build Recipe", metavar="")
    parser.add_option("-a", "--start", dest="start_number",
                      help="build recipe starting at line number A", metavar="")
    parser.add_option("-z", "--stop", dest="stop_number",
                      help="build recipe no further than line number Z", metavar="")
    parser.add_option("-p", "--pull-sources", dest="pull_sources",
                      help="Download sources from from/for a recipe", metavar="")
    parser.add_option("-l", "--list-stack", action="store_true", dest="list_stack",
                      help="List state of system stack", metavar="")
    parser.add_option("-L", "--list-snapshots", action="store_true", dest="list_snaps",
                      help="List state of system stack", metavar="")
    parser.add_option("-r", "--record-snapshot", dest="snapshot",
                      help="Build temp toolchain.", metavar="")
    parser.add_option("-d", "--default-snapshot", dest="defsnap",
                      help="Set Default snapshot to boot from.", metavar="")
    parser.add_option("-q", "--quiet",
                      action="store_false", dest="verbose", default=True,
                      help="don't print status messages to stdout")


    if 0 != os.geteuid():
        error("User not permitted. Exiting.")
        return FAILURE

    (options, args) = parser.parse_args()

    if options.physix_conf:
        sys.exit(do_partition_init(options))

    if options.toolchain_conf:
        sys.exit(do_toolchain_build(options))

    if options.base_conf:
        sys.exit(do_base_build(options))

    if options.configure_base_conf:
        sys.exit(do_config_base(options))

    if options.build_recipe:
        sys.exit(do_build_recipe(options))

    if options.pull_sources:
        sys.exit(do_pull_sources(options))

    if options.list_stack:
        sys.exit(do_list_stack(options))

    if options.list_snaps:
        sys.exit(do_list_snapshots())

    if options.snapshot:
        sys.exit(do_snapshot(options))

    if options.defsnap:
        sys.exit(do_set_default_snapshot(options))

if __name__ == '__main__':
    signal(SIGINT, handler)
    main()

