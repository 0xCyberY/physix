#!/usr/bin/python3
import os
import sys
import json
import tarfile
import logging
import datetime
import subprocess
from optparse import OptionParser

BUILDROOT = "/mnt/physix"

#---------------------------------------------
# INIT FUNCTIONS
#---------------------------------------------
def validate(rtn, msg, report=False):
    """ Verify return code and log appropriate message """
    rcode = int(rtn[0])
    if rcode == 0:
        if report == True:
            ok(msg)
        else:
            return

    if rcode != 0:
        error(msg)


def info(msg):
    """ write info message to log """
    print("\033[0;33;48m [INFO] \033[0m " + msg)
    logging.info(msg)


def error(msg):
    """ write error message to log """
    msg = "\033[0;31;48m [ERROR] \033[0m " + msg
    print(msg)
    logging.error(msg)
    sys.exit(1)


# \e[92m[OK]\e[0m
def ok(msg):
    """ write success message to log """
    msg = "\033[0;32;48m [OK] \033[0m   " + msg
    print(msg)
    logging.info(msg)


def load_recipe(cfg):
    """ Read in recipe as dict """
    with open(cfg) as file_desc:
        return json.load(file_desc)


def load_build_config(cfg):
    """ cfg : string """
    config = {}
    with open(cfg, "r") as file_desc:
        lines = file_desc.readlines()
        for line in lines:
            line = line.strip().strip().strip("\n")

            if line.startswith('#') or len(line) == 0:
                continue

            lst = line.split("=")
            if len(lst) != 2:
                error("Unexpected Format")

            cfg = str(lst[0])
            val = str(lst[1])
            config[cfg] = val
    return config


#---------------------------------------------
#---------------------------------------------
def verify_checker(config):
    """ config : {} """
    for tool in ['mkfs.ext3', 'gcc', 'g++', 'make', 'gawk', 'bison']:
        ret_tpl = run_cmd(['which', tool])
        validate(ret_tpl, "Check: "+ tool)

    root_dev = config["CONF_ROOT_DEVICE"]
    devlst = os.listdir("/dev")
    dev_count = sum(1 for ln in devlst if root_dev in ln)
    if dev_count > 1:
        msg = "".join(["Found Existing partition(s) on: /dev/", root_dev,
                       "Please remove them and restart this opperation"])
        error(msg)
        #error("Found Existing partition(s) on:
        #/dev/"+root_dev+"\nPlease remove them and restart this opperation")
        return False

    return True


#---------------------------------------------
#---------------------------------------------
def create_partitions(config):
    """ config : {} """
    root_device = "/dev/" + config["CONF_ROOT_DEVICE"]
    root_device = root_device.strip("\n")

    # UEFI 1
    uefi_size = config["CONF_UEFI_PART_SIZE"].strip("\n")
    #cmd = ["parted", root_device, "mkpart", "primary", "1", uefi_size]
    ret_tpl = run_cmd(["parted", root_device, "mkpart", "primary", "1", uefi_size])
    validate(ret_tpl, "Create UEFI Partition")

    # BOOT PART
    boot_size = config["CONF_BOOT_PART_SIZE"].strip("\n")
    boot_boundery = str(int(uefi_size) + int(boot_size))
    #cmd = ['parted', root_device, "mkpart", "primary", uefi_size, boot_boundery]
    ret_tpl = run_cmd(['parted', root_device, "mkpart", "primary", uefi_size, boot_boundery])
    validate(ret_tpl, "Create /boot Partition")

    psize = config['CONF_PHYS_ROOT_PART_SIZE'].strip("\n")
    phys_boundery = str(int(boot_boundery) + int(psize))
    #cmd = ['parted', root_device, "mkpart", "primary", boot_boundery, phys_boundery]
    ret_tpl = run_cmd(['parted', root_device, "mkpart", "primary", boot_boundery, phys_boundery])
    validate(ret_tpl, "Create ROOT Partition")

    #cmd = ['parted', root_device, 'set', '1', 'boot', 'on']
    ret_tpl = run_cmd(['parted', root_device, 'set', '1', 'boot', 'on'])
    validate(ret_tpl, "Boot Flag Set to "+root_device)

    return True


#---------------------------------------------
#---------------------------------------------
def create_volumes(config):
    """ Create lvm volumes """

    system_root = "/dev/" + config["CONF_ROOT_DEVICE"].strip('\n')
    system_root = system_root + "3"
    ret_tpl = run_cmd(['pvcreate', '-ff', '-y', system_root])
    validate(ret_tpl, "Physical Volume Create: "+system_root)

    vol_group_name = config["CONF_VOL_GROUP_NAME"].strip("\n")
    #cmd = ['vgcreate', '-ff', vol_group_name, system_root]
    ret_tpl = run_cmd(['vgcreate', '-ff', vol_group_name, system_root])
    validate(ret_tpl, "")

    root_vol_size = str(config["CONF_LOGICAL_ROOT_SIZE"].strip('\n'))+"G"
    ret_tpl = run_cmd(['lvcreate', '--yes', '-L', root_vol_size, '-n', 'root', vol_group_name])
    validate(ret_tpl, "Volume Create: root")

    home_vol_size = str(config["CONF_LOGICAL_HOME_SIZE"].strip('\n')) + "G"
    ret_tpl = run_cmd(["lvcreate", '--yes', "-L", home_vol_size, '-n', 'home', vol_group_name])
    validate(ret_tpl, "Volume Create: home")

    var_vol_size = str(config["CONF_LOGICAL_VAR_SIZE"].strip('\n')) + "G"
    ret_tpl = run_cmd(["lvcreate", '--yes', "-L", var_vol_size, '-n', 'var', vol_group_name])
    validate(ret_tpl, "Volume Create: var")

    usr_vol_size = str(config["CONF_LOGICAL_USR_SIZE"].strip('\n')) + "G"
    ret_tpl = run_cmd(["lvcreate", '--yes', "-L", usr_vol_size, '-n', 'usr', vol_group_name])
    validate(ret_tpl, "Volume Create: usr")

    opt_vol_size = str(config["CONF_LOGICAL_OPT_SIZE"].strip('\n')) + "G"
    ret_tpl = run_cmd(["lvcreate", '--yes', "-L", opt_vol_size, '-n', 'opt', vol_group_name])
    validate(ret_tpl, "Volume Create: opt")

    tmp_vol_size = str(config["CONF_LOGICAL_TMP_SIZE"].strip('\n')) + "G"
    ret_tpl = run_cmd(["lvcreate", '--yes', "-L", tmp_vol_size, '-n', 'tmp', vol_group_name])
    validate(ret_tpl, "Volume Create: opt")

    return True

#---------------------------------------------
#---------------------------------------------
def format_volumes(config):
    """ Format lvm volumes and partitions """

    system_root = "/dev/" + config["CONF_ROOT_DEVICE"].strip('\n')
    # this should not be necessary. build_config should take care of this.
    vol_group_name = config["CONF_VOL_GROUP_NAME"].strip('\n')

    part1 = system_root + "1"
    ret_tpl = run_cmd(['mkfs.fat', part1])
    validate(ret_tpl, "mkfs.fat: " + part1)

    part2 = system_root + "2"
    ret_tpl = run_cmd(['mkfs.ext2', part2])
    validate(ret_tpl, "mkfs.ext2: " + part2)

    physix_root = "/dev/mapper/" + vol_group_name + "-root"
    ret_tpl = run_cmd(['mkfs.ext4', physix_root])
    validate(ret_tpl, "mkfs.ext4: " + physix_root)

    physix_home = "/dev/mapper/" + vol_group_name + "-home"
    ret_tpl = run_cmd(['mkfs.ext4', physix_home])
    validate(ret_tpl, "mkfs.ext4: " + physix_home)

    physix_var = "/dev/mapper/" + vol_group_name + "-var"
    ret_tpl = run_cmd(['mkfs.ext4', physix_var])
    validate(ret_tpl, "mkfs.ext4: " + physix_var)

    physix_usr = "/dev/mapper/" + vol_group_name + "-usr"
    ret_tpl = run_cmd(['mkfs.ext4', physix_usr])
    validate(ret_tpl, "mkfs.ext4: " + physix_usr)

    physix_opt = "/dev/mapper/" + vol_group_name + "-opt"
    ret_tpl = run_cmd(['mkfs.ext4', physix_opt])
    validate(ret_tpl, "mkfs.ext4: " + physix_opt)

    physix_tmp = "/dev/mapper/" + vol_group_name + "-tmp"
    ret_tpl = run_cmd(['mkfs.ext4', physix_tmp])
    validate(ret_tpl, "mkfs.ext4: " + physix_tmp)

    return True

#---------------------------------------------
#--------------------------------------------
def mount_volumes(config):
    """ Mount volumes and partitions """

    vol_group_name = "physix"

    if not os.path.exists(BUILDROOT):
        os.mkdir(BUILDROOT, 755)

    volume_root = "/dev/mapper/" + vol_group_name + "-root"
    ret_tpl = run_cmd(['mount', volume_root, BUILDROOT])
    validate(ret_tpl, "Mount: "+volume_root)

    mnt_point = BUILDROOT + "/home"
    os.mkdir(mnt_point, 0o755)
    volume_home = "/dev/mapper/" + vol_group_name + "-home"
    ret_tpl = run_cmd(['mount', volume_home, mnt_point])
    validate(ret_tpl, "Mount: " + volume_home)

    var = BUILDROOT + "/var"
    os.mkdir(var, 0o755)
    volume_var = "/dev/mapper/" + vol_group_name + "-var"
    mnt_point = BUILDROOT + "/var"
    ret_tpl = run_cmd(['mount', volume_var, mnt_point])
    validate(ret_tpl, "Mount: " + volume_var)

    usr = BUILDROOT + "/usr"
    os.mkdir(usr, 0o755)
    volume_usr = "/dev/mapper/" + vol_group_name + "-usr"
    mnt_point = BUILDROOT + "/usr"
    ret_tpl = run_cmd(['mount', volume_usr, mnt_point])
    validate(ret_tpl, "Mount: " + volume_usr)

    opt = BUILDROOT + "/opt"
    os.mkdir(opt, 0o755)
    volume_opt = "/dev/mapper/" + vol_group_name + "-opt"
    mnt_point = BUILDROOT + "/opt"
    ret_tpl = run_cmd(['mount', volume_opt, mnt_point])
    validate(ret_tpl, "Mount: " + volume_opt)

    boot = BUILDROOT + "/boot"
    os.mkdir(boot, 0o755)
    boot_part = "/dev/" + config["CONF_ROOT_DEVICE"].strip('\n') + "2"
    ret_tpl = run_cmd(['mount', boot_part, boot])
    validate(ret_tpl, "Mount: " + boot_part)

    return True


#----------------------------------------------------
#---------------------------------------------------
def pull_sources(recipe, dest):
    """ Download sources """
    dir_prefix = '--directory-prefix=' + dest
    rsize = len(recipe)

    #if not os.path.exists("/mnt/physix/opt/sources.physix/"):
    #    os.mkdir("/mnt/physix/opt/sources.physix/", 0o755)

    if not os.path.exists(dest):
        os.mkdir(dest, 0o755)
        if not os.path.exists(dest):
            error("Destination Path Creation Failed:" + dest)

    pull_lst = []
    for i in range(rsize):
        sources = recipe[str(i)]["sources"]
        for key in sources.keys():
            pull_lst.append(key)

    for url in pull_lst:
        if url:
            ret_tpl = run_cmd(['wget', '-q', '--continue', dir_prefix, url])
            validate(ret_tpl, "Download:"+url, True)


#---------------------------------------------
#--------------------------------------------
def setup(config):
    """ Setup environment for systemd build """
    if not os.path.exists(BUILDROOT+"/opt/logs.physix"):
        os.mkdir(BUILDROOT+"/opt/logs.physix", 777)
    if not os.path.exists(BUILDROOT+"/opt/sources.physix"):
        os.mkdir(BUILDROOT+"/opt/sources.physix", 770)

    # First find bash
    ret_tpl = run_cmd(['ln', '-sfv', '/usr/bin/bash', '/usr/bin/sh'])
    validate(ret_tpl, "link bash to 'sh/bash'")

    # First find gawk
    ret_tpl = run_cmd(['ln', '-sfv', '/usr/bin/gawk', '/usr/bin/awk'])
    validate(ret_tpl, "link gawk to 'awk/gawk'")

    # First find bison
    ret_tpl = run_cmd(['ln', '-sfv', '/usr/bin/bison', '/usr/bin/yacc'])
    validate(ret_tpl, "link gawk to 'yacc/bison'")

    tools = BUILDROOT+"/tools"
    ret_tpl = run_cmd(['ln', '-sfv', tools, '/'])
    validate(ret_tpl, "link tools dir")

    (rtn, out, err) = run_cmd(['grep', 'physix', '/etc/passwd'])
    if int(rtn) != 0:
        ret_tpl = run_cmd(['useradd', '-s', '/bin/bash', '-m', 'physix'])
        validate(ret_tpl, "useradd physix")

    src = str(os.getcwd()) + "/build-scripts/03-base-config/configs/physix-bashrc"
    dest = "/home/physix/.bashrc"
    ret_tpl = run_cmd(['cp', src, dest])
    validate(ret_tpl, "set physix user's .bashrc file")

    tools_dir = BUILDROOT + "/tools"
    os.mkdir(tools_dir, 0o755)
    ret_tpl = run_cmd(['chown', '-v', 'physix', tools_dir])
    validate(ret_tpl, "chown "+tools_dir)

    ret_tpl = run_cmd(['chmod', '750', tools_dir])
    validate(ret_tpl, "chmod 770 "+tools_dir)

    sources_dir = BUILDROOT + "/opt/sources.physix"
    ret_tpl = run_cmd(['chown', '-v', 'physix', sources_dir])
    validate(ret_tpl, "chown "+sources_dir)

    ret_tpl = run_cmd(['chmod', '750', sources_dir])
    validate(ret_tpl, "chmod 750 "+sources_dir)

    info("Downloading Sources")
    if config['CONF_UTILS'] != '':
        recipe = load_recipe(config['CONF_UTILS'])
        pull_sources(recipe, "/mnt/physix/opt/sources.physix")

    ret_tpl = run_cmd(['mv', os.getcwd(), '/mnt/physix/opt/'])
    validate(ret_tpl, "Move physix repo to /mnt/physix/opt/")


#---------------------------------------------
#---------------------------------------------
def build_toolchain(recipe, context, build_num=0):
    """ Build the temorary toolchain from recipe """
    pull_sources(recipe, "/mnt/physix/opt/sources.physix")

    for i in range(build_num, len(recipe)):
        element = recipe[str(i)]

        stat = " ".join(["Build [", str(i), "/", str(len(recipe)), "] Toolchain" ] )
        info(stat)
        if not refresh_build_box("NON-CHRT"):
            error("refresh_build_box")

        ''' Fails on error '''
        unpack(element, context)
        
        """ Dir name of First tarball in list is passed as arg to the 
            build script """
        if element["archives"] != []:
            bsp = "/mnt/physix/opt/sources.physix/"+ str(element["archives"][0])
            build_src = top_most_dir(bsp)
        else:
            build_src = ''

        subcmd = os.path.join('/mnt/physix/opt/physix/build-scripts/',
                              str(element["group"]),
                              str(element["build_script"]))
        subcmd = " ".join([subcmd, build_src])
        cmd = ['su', 'physix', '-c', subcmd]

        info("Building " + str(cmd))
        ret_tpl = run_cmd_log(cmd, str(element["build_script"]), "")
        validate(ret_tpl, "Build: " + str(cmd), True)


#---------------------------------------------
#---------------------------------------------
def build_recipe(recipe, context, build_num):
    """ Build recipe """

    #pull_sources(recipe, "/opt/sources.physix")

    for i in range(build_num, len(recipe)):
        element = recipe[str(i)]

        stat = " ".join(["Building [", str(i), "/", str(len(recipe)), "]" ] )
        info(stat)
        if not refresh_build_box("CHRT"):
            error("refresh_build_box")

        unpack(element, context)
        #if len(dir_list) == 0:
        #    sources = ''
        #else:
        #    sources = " ".join(dir_list)

        """ Dir name of First tarball in list, is passed as arg to the 
            build script """
        Z = "/mnt/physix/opt/sources.physix/BUILDBOX" + element["archives"][0]
        build_src = top_most_dir(Z)

        subcmd = os.path.join('/opt/physix/build-scripts/',
                              str(element["group"]),
                              str(element["build_script"]))
        cmd = [subcmd, build_src]

        info("Executing Build: " + "[" + str(build_num) + "] " + str(cmd))
        ret_tpl = run_cmd_log(cmd, str(element["build_script"]), context)
        validate(ret_tpl, "Build: "+str(cmd), True)


#---------------------------------------------
# Input: string - recipe : Recipe file path
# Input: string - chroot or non chroot context
# Input: int - Start building from recipe at line number
#---------------------------------------------
def build_base(recipe, context, build_num):
    """ Build base system from recipe """

    if build_num == 0:
        cmd = ['/mnt/physix/opt/physix/build-scripts/02-base/2.000-base-build-prep.sh']
        ret_tpl = run_cmd_log(cmd, "2.000-base-build-prep.sh", "")
        validate(ret_tpl, "Build: " + str(cmd))

    pull_sources(recipe, "/mnt/physix/opt/sources.physix")

    for i in range(build_num, len(recipe)):
        element = recipe[str(i)]

        stat = " ".join(["Building [", str(i), "/", str(len(recipe)), "] Base System" ] )
        info(stat)
        if not refresh_build_box("NON-CHRT"):
            error("\nRefresh_BUILDBOX")

        unpack(element, context)

        """ Dir name of First tarball in list, is passed as arg to the 
            build script """
        if element["archives"] != []:
            bsp = "/mnt/physix/opt/sources.physix/"+ str(element["archives"][0])
            build_src = top_most_dir(bsp)
        else:
            build_src = ''

        cmd = ['/mnt/physix/opt/physix/build-scripts/02-base/000-chroot_stub.sh',
               str(element["build_script"]),
               build_src]
        info("Executing Build: " + "[" + str(build_num) + "] " + str(cmd))
        ret_tpl = run_cmd_log(cmd, str(element["build_script"]), "")
        validate(ret_tpl, "Build: " + str(cmd), True)


#---------------------------------------------
# Sees system as /mnt/physix/opt/physix
#---------------------------------------------
def config_base_system(recipe, context, build_num):
    """ Configure the base system from recipe """
    pull_sources(recipe, "/mnt/physix/opt/sources.physix")

    for i in range(build_num, len(recipe)):
        element = recipe[str(i)]

        stat = " ".join(["Building [", str(i), "/", str(len(recipe)), "] Config Base System" ])
        info(stat)
        if not refresh_build_box("NON-CHRT"):
            error("refresh_build_box")

        """ Fails on error """
        unpack(element, context)

        """ Dir name of First tarball in list, is passed as arg to the 
            build script """
        if element["archives"] != []:
            bsp = "/mnt/physix/opt/sources.physix/"+ str(element["archives"][0])
            build_src = top_most_dir(bsp)
        else:
            build_src = ''

        cmd = ['/mnt/physix/opt/physix/build-scripts/03-base-config/000-conf_chrrot_stub.sh',
               str(element["build_script"]),
               build_src]
        info("Executing Build: " + "[" + str(build_num) + "] " + str(cmd))
        ret_tpl = run_cmd_log(cmd, str(element["build_script"]), "")
        validate(ret_tpl, "Build: "+str(cmd), True)

    """ Special case for user to set password without logging"""
    cmd = ['/mnt/physix/opt/physix/build-scripts/03-base-config/000-conf_chrrot_stub.sh',
           '3.111-set-passwd.sh']
    run_cmd_live(cmd)


#---------------------------------------------
#---------------------------------------------
def run_cmd_log(cmd, name, context):
    """ run command and log I/O to log file  """
    date = format(datetime.datetime.now())
    date = date.replace(":", "-").replace(" ", "-")
    log_name = date + "-" + name

    if context == "CHRT":
        log_path = "/opt/logs.physix/" + log_name
    else:
        log_path = "/mnt/physix/opt/logs.physix/" + log_name

    with open(log_path, "w") as file_desc:
        try:
            p = subprocess.run(cmd, stdout=file_desc, stderr=file_desc)
            rtn = int(p.returncode)
        except Exception as exc:
            error("[ERROR] Opperation Failed:"+str(exc)),

    return (rtn, "", "")


#---------------------------------------------
#---------------------------------------------
def run_cmd(cmd):
    """ Run command, return caputured I/O Streams """
    #info("\nRunning: " + str(cmd))
    out = ''
    err = ''
    try:
        p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        rtn = int(p.returncode)
        out = str(p.stdout)
        err = str(p.stderr)
    except Exception as exc:
        error("[Exceotion] Opperation Failed:\n "+str(exc))

    rtn = (int(rtn), str(out), str(err))
    #info("Returning:" + str(rtn))
    return rtn

#-----------------------------------------------------
#-----------------------------------------------------
def run_cmd_live(cmd):
    """ run commmand, don't capture output  """
    try:
        proc = subprocess.run(cmd)
        rtn = int(proc.returncode)
    except Exception as exc:
        error("[ERROR] run_cmd Execption."+str(exc)),
    return (rtn, "", "")


#-----------------------------------------------------
# Input: string - path to archive
# Output: string -  top most directory from archive
#-----------------------------------------------------
def top_most_dir(archive_path):
    """ Return direcetory name encaped in tar archive """
    archive_path = archive_path.strip().strip("\n")
    if not os.path.exists(archive_path):
        error("Expected path does not exist: " + archive_path)
    with tarfile.open(archive_path, mode='r') as archive:
        return str(os.path.commonprefix(archive.getnames()))


#---------------------------------------------
#---------------------------------------------
def refresh_build_box(context):
    """ Remove and Re-create BUILDBOX """

    if context == "CHRT":
        bb_path = "/opt/sources.physix/BUILDBOX"
    elif context == "NON-CHRT":
        bb_path = "/mnt/physix/opt/sources.physix/BUILDBOX"
    else:
        error("in the dirt")

    if os.path.exists(bb_path):
        ret_tpl = run_cmd(['rm', '-r', bb_path])
        validate(ret_tpl, '')

        os.mkdir(bb_path, 0o700)
        ret_tpl = run_cmd(['mkdir', '-p', bb_path])
        validate(ret_tpl, "mkdir bb_path: " + bb_path)

        ret_tpl = run_cmd(['chown', 'physix:root', bb_path])
        validate(ret_tpl, "chown physix " + bb_path)
    else:
        os.mkdir(bb_path, 0o700)
        ret_tpl = run_cmd(['chown', 'physix:root', bb_path])
        validate(ret_tpl, "chown physix " + bb_path)

    return True


def sort_sources(src_path, element):
    extract_list = []
    #if instead we use pkgs then we wohn't have to dig though sources
    for url in element["sources"].keys():
        if url:
            fname = src_path + url.split("/")[-1]
            extention = fname.split(".")[-1]
            if extention == "patch":
                ret_tpl = run_cmd(['cp', fname, bb_path])
                validate(ret_tpl, "cp patch: "+fname)
            else:
                info("Adding to arch list"+str(fname))
                extract_list.append(fname)
    info("Archive List is:"+str(archive_list))


def extract_archives():
    return True

#---------------------------------------------
# This is hard to read. re-write better
# input: element:dict, context:string
# output: list of directory names from extracted tarbballs
#---------------------------------------------
def unpack(element, context):
    """ Move extract archives, and patches to BUILDBOX dir """
    dir_list = []
    archive_list = []

    if element['archives'] == []:
        return []

    # Archives are stored in 1 or 2 paths, depending on
    # whether executed in chrooted or non-chrooted context
    if context == "CHRT":
        src_path = "/opt/sources.physix/"
        bb_path = "/opt/sources.physix/BUILDBOX/"
    else:
        src_path = '/mnt/physix/opt/sources.physix/'
        bb_path = '/mnt/physix/opt/sources.physix/BUILDBOX/'

    if not os.path.exists(bb_path):
        os.mkdir(bb_path, 0o755)

    for patch in element["patches"]:
        patch_path = src_path + patch
        ret_tpl = run_cmd(['cp', patch_path, bb_path])
        validate(ret_tpl, 'move patch')

    for archive in element["archives"]: 
        archive_path = src_path + archive
        if ('tar' in archive) or ('tgz' in archive):
            info('Unpacking:'+archive)
            ret_tpl = run_cmd(['tar', 'xf', archive_path, '-C', bb_path])
            validate(ret_tpl, 'unpack to buildbox :' + archive_path)
        elif 'bz2' in archive:
            asrc = src_path + archive
            adest = bb_path + archive
            ret_tpl = run_cmd(['cp', asrc, bb_path])
            validate(ret_tpl, 'cp to BUILDBOX: ' + asrc)
            ret_tpl = run_cmd(['bunzip2', '-dk', adest])
            validate(ret_tpl, 'bunzip2: ' + adest)

    # ASSIGN OWNERSHIP TO 'physix'
    ret_tpl = run_cmd(['chown', '--recursive', 'physix:root', bb_path])
    validate(ret_tpl, "")

    return True


if __name__ == '__main__':

    START = 0

    parser = OptionParser()
    parser.add_option("-i", "--build-init", dest="build_conf",
                      help="Initialize system build process.", metavar="")
    parser.add_option("-t", "--build-toolchain", dest="toolchain_conf",
                      help="Build temp toolchain.", metavar="")
    parser.add_option("-s", "--build-base-system", dest="base_conf",
                      help="Build the Base System. ", metavar="")
    parser.add_option("-c", "--base-system-config", dest="configure_base_conf",
                      help="Configure Base system.",
                      metavar="")
    parser.add_option("-b", "--build-recipe", dest="build_recipe",
                      help="Build Recipe", metavar="")
    parser.add_option("-a", "--start", dest="start_number",
                      help="build recipe starting at line N", metavar="")
    parser.add_option("-z", "--stop", dest="stop_number",
                      help="build recipe no further than line N", metavar="")
    parser.add_option("-f", "--file-snopshot", dest="file_snap",
                      help="Record md5sum of all files under core systemd directoryes", metavar="")

    parser.add_option("-q", "--quiet",
                      action="store_false", dest="verbose", default=True,
                      help="don't print status messages to stdout")

    (options, args) = parser.parse_args()
    print(str(options))


    if options.build_conf:
        logging.basicConfig(filename='/tmp/physix-build.log', level=logging.DEBUG)

        BUILD_CONFIG = load_build_config(options.build_conf)

        # rename sysreq_check
        if not verify_checker(BUILD_CONFIG):
            error("Systemd Requirement check")
        ok("Systemd Requirement check")

        info("Creating Partitions")
        if not create_partitions(BUILD_CONFIG):
            error("Creating Partitions")
        ok("Creating Partitions")

        info("Create Volumes")
        if not create_volumes(BUILD_CONFIG):
            error("Create Volumes")
        ok("Create Volumes")

        info("Format Volumes")
        if not format_volumes(BUILD_CONFIG):
            error("Format Volumes")
        ok("Format Volumes")

        info("Mounting Volumes")
        if not mount_volumes(BUILD_CONFIG):
            error("Mounting Volumes")
        ok("Mounting Volumes")

        setup(BUILD_CONFIG)

        info("------------------------------------")
        info("- Build initialization completete!")
        info("- Next Step: Build the toolchain.")
        info("- 1. cd /mnt/physix/opt/physix")
        info("- 2. ./physix-tool -t 01-toolchain.json")
        info("------------------------------------")



    if options.start_number:
        START = int(options.start_number)



    if options.toolchain_conf:
        if os.path.exists("/tmp/physix-build.log"):
            CMD = ['mv', '/tmp/physix-build.log', '/mnt/physix/opt/logs.physix/']
            if (run_cmd(CMD))[1] != 0:
                ok("Relocated physix-build.log to /mnt/physix/opt/logs.physix/")
        logging.basicConfig(filename='/mnt/physix/opt/logs.physix/physix-build.log',
                            level=logging.DEBUG)
        info("build toolchain...")
        RECIPE_NAME = str(options.toolchain_conf)
        RECIPE = load_recipe(RECIPE_NAME)
        build_toolchain(RECIPE, "NON-CHRT", START)

        info("------------------------------------")
        info("- Toolchain Build Completete!")
        info("- Next Step: Build the toolchain.")
        info("- ./physix-tool -s 02-base-system.json ")
        info("------------------------------------")



    if options.base_conf:
        logging.basicConfig(filename='/mnt/physix/opt/logs.physix/physix-build.log',
                            level=logging.DEBUG)
        info("Building Base System...")
        RECIPE_NAME = str(options.base_conf)
        RECIPE = load_recipe(RECIPE_NAME)
        build_base(RECIPE, "NON-CHRT", START)

        info("------------------------------------")
        info("- Base System Build Completete!")
        info("- Next Step: Build the toolchain.")
        info("- 1. ./physix-tool -c 03-config-base.json")
        info("------------------------------------")




    if options.configure_base_conf:
        logging.basicConfig(filename='/mnt/physix/opt/logs.physix/physix-build.log',
                            level=logging.DEBUG)
        info("Configure Base System...")
        info("Building Base System...")
        RECIPE_NAME = str(options.configure_base_conf)
        RECIPE = load_recipe(RECIPE_NAME)
        config_base_system(RECIPE, "NON-CHRT", START)


    if options.build_recipe:
        logging.basicConfig(filename='/opt/logs.physix/physix-build.log',
                            level=logging.DEBUG)
        info("Building Recipe")
        RECIPE_NAME = str(options.build_recipe)
        RECIPE = load_recipe(RECIPE_NAME)
        build_recipe(RECIPE, "CHRT", START)
